'\" te
.\" Copyright (c) 1982-2007 AT&T Knowledge Ventures
.\" To view license terms, see http://www.eclipse.org/org/documents/epl-v10.html
.\" Portions Copyright (c) 2009, Sun Microsystems, Inc.
.\" Portions Copyright 2021 OmniOS Community Edition (OmniOSce) Association.
.Dd March 8, 2021
.Dt KSH93 1
.Os
.Sh NAME
.Nm ksh93 ,
.Nm rksh93
.Nd  Korn Shell, a standard and restricted command and programming language
.Sh SYNOPSIS
.Nm ksh93
.Op Sy \&+ Ns Fl abcefhikmnoprstuvxBCD
.Op Fl R Ar file
.Op Sy \&+ Ns Fl o Ar option
\&...
.Op Fl
.Op Ar arg No ...
.Nm rksh93
.Op Sy \&+ Ns Fl abcefhikmnoprstuvxBCD
.Op Fl R Ar file
.Op Sy \&+ Ns Fl o Ar option
\&...
.Op Fl
.Op Ar arg No ...
.Sh DESCRIPTION
.Nm
is a command and programming language that executes commands read
from a terminal or a file.
.Nm rksh93
is a restricted version of the command interpreter
.Nm ksh93 .
.Nm rksh93
is used to set up login names and execution environments whose capabilities are
more controlled than those of the standard shell.
.Pp
See
.Sx Invocation
for the meaning of arguments to the shell.
.Ss "Definitions"
A
.Sy metacharacter
is defined as one of the following characters:
.Pp
.Dl ; & ( \  ) | < > NEWLINE SPACE TAB
.Pp
A
.Sy blank
is a TAB or a SPACE.
.Pp
An
.Sy identifier
is a sequence of letters, digits, or underscores starting with a letter or
underscore.
Identifiers are used as components of variable names.
.Pp
A
.Sy vname
is a sequence of one or more identifiers separated by a period
.Pq Sy \&.
and optionally preceded by a period
.Pq Sy \&. .
.Sy vname Ns s
are used as function and variable names.
.Pp
A
.Sy word
is a sequence of characters from the character set defined by the current
locale, excluding non-quoted
.Sy metacharacter Ns s .
.Pp
A
.Sy command
is a sequence of characters in the syntax of the shell language.
The shell reads each command and carries out the desired action either directly
or by invoking separate utilities.
A built-in command is a command that is carried out by the shell itself without
creating a separate process.
Some commands are built-in purely for convenience and are not documented in
this manual page.
Built-ins that cause side effects in the shell environment and built-ins that
are found before performing a path search
.Pq see Sx Execution
are documented in this manual page.
For historical reasons, some of these built-ins behave differently than other
built-ins and are called special built-ins.
.Ss "Commands"
A
.Sy simple-command
is a list of variable assignments
.Pq see Sx Variable Assignments
or a sequence of
.Sy blank Ns -separated
words which can be preceded by a list of variable assignments.
See the
.Sx Environment
section of this manual page.
.Pp
The first word specifies the name of the command to be executed.
Except as specified in this section, the remaining words are passed as
arguments to the invoked command.
The command name is passed as argument 0.
See
.Xr exec 2 .
The
.Em value
of a simple-command is its exit status.
If it terminates normally, its value is between
.Sy 0
and
.Sy 255 .
If it terminates abnormally, its value is
.Sy 256 +
.Em signum .
The name of the signal corresponding to the exit status can be obtained by way
of the
.Fl l
option of the
.Ic kill
built-in utility.
.Pp
A
.Sy pipeline
is a sequence of one or more commands separated by
.Sy \&| .
The standard output of each command but the last is connected by a
.Xr pipe 2
to the standard input of the next command.
Each command, except possibly the last, is run as a separate process.
The shell waits for the last command to terminate.
The exit status of a pipeline is the exit status of the last command unless the
.Sy pipefail
option is enabled.
Each pipeline can be preceded by the reserved word
.Sy \&! .
This causes the exit status of the
pipeline to become
.Sy 0
if the exit status of the last command is
.Sy non-zero ,
and
.Sy 1
if the exit status of the last command is
.Sy 0 .
.Pp
A
.Sy list
is a sequence of one or more pipelines separated by
.Sy \&; ,
.Sy \&& ,
.Sy \&|& ,
.Sy \&&& ,
or
.Sy \&| ,
and optionally terminated by
.Sy \&; ,
.Sy \&& ,
or
.Sy \&|& .
Of these
five symbols,
.Sy \&; ,
.Sy \&& ,
and
.Sy \&|&
have equal precedence, which is lower than that of
.Sy \&&&
and
.Sy || .
The symbols
.Sy \&&&
and
.Sy ||
have equal precedence.
.Pp
A semicolon
.Pq Sy \&;
causes sequential execution of the preceding pipeline.
An ampersand
.Pq Sy \&&
causes asynchronous execution of the preceding pipeline, that is, the shell
does
.Em not
wait for that pipeline to finish.
The symbol
.Sy \&|&
causes asynchronous execution of the preceding pipeline with a two-way pipe
established to the parent shell.
The standard input and output of the spawned pipeline can be written to and
read from by the parent shell by applying the redirection operators
.Sy \&<&
and
.Sy \&>&
with
.Cm arg p
to
commands and by using
.Fl p
option of the built-in commands
.Ic read
and
.Ic print .
The symbol
.Sy \&&&
.Pq Sy ||
causes the
.Ar list
following it to be executed only if the preceding pipeline returns a zero
.Pq non-zero
value.
One or more NEWLINEs can appear in a
.Ar list
instead of a semicolon, to delimit a command.
The first
.Ar item
of the first
.Ar pipeline
of a
.Ar list
that is a simple command not beginning with a redirection, and not occurring
within a
.Ic while ,
.Ic until ,
or
.Ic if
.Ar list ,
can be preceded by a semicolon.
This semicolon is ignored unless the
.Sy showme
option is enabled as described with the
.Ic set
built-in.
.Pp
A
.Sy command
is either a simple-command or one of commands in the following list.
Unless otherwise stated, the value returned by a command is that of the
last simple-command executed in the command.
.Pp
.Bl -tag -width Ds -compact
.It Xo
.Ic for Ar vname
.Op Cm in Ar word No ...
.Ic ;do Ar list Ic ;done
.Xc
.Pp
Each time a
.Ic for
command is executed,
.Ar vname
is set to the next
.Ar word
taken from the
.Ic in
.Ar word
list.
If
.Ic in
.Ar word ...
is omitted, the
.Ic for
command executes the
.Ic do
.Ar list
once for each positional parameter that is set starting from 1.
Execution ends when there are no more words in the list.
See
.Sx Parameter Expansion .
.Pp
.It Xo
.Ic for
.Sy ((
.Op Ar expr1
.Sy \&; Op Ar expr2
.Sy \&; Op Ar expr3
.Sy ))
.Ic ;do Ar list Ic ;done
.Xc
.Pp
The arithmetic expression
.Ar expr1
is evaluated first.
The arithmetic expression
.Ar expr2
is repeatedly evaluated until it evaluates to
.Sy zero
and when
.Sy non-zero ,
.Ar list
is executed and the arithmetic expression
.Ar expr3
is evaluated.
If any expression is omitted, then it behaves as if it evaluated to
.Sy 1 .
See
.Sx Arithmetic Evaluation .
.Pp
.It Xo
.Ic select Ar vname
.Op Sy in Ar word No ...
.Ic ;do Ar list Ic ;done
.Xc
.Pp
A
.Ic select
command prints on standard error (file descriptor 2) the set of
.Ar words ,
each preceded by a number.
If
.Ic in Ar word ...
is omitted, the positional parameters starting from
.Sy 1
are used instead.
See
.Sx Parameter Expansion .
The
.Ev PS3
prompt is printed and a line is read from the standard input.
If this line consists of the number of one of the listed
.Ar word Ns No s ,
then the value of the variable
.Ar vname
is set to the
.Ar word
corresponding to this number.
If this line is empty, the selection list is printed again.
Otherwise the value of the variable
.Ar vname
is set to
.Dv NULL .
The contents of the line read from standard input is saved in the variable
.Ev REPLY .
The
.Ar list
is executed for each selection until a break or
.Dv EOF
is encountered.
If the
.Ev REPLY
variable is set to
.Dv NULL
by the execution of
.Ar list ,
the selection list is printed before displaying the
.Ev PS3
prompt for the next selection.
.Pp
.It Xo
.Ic case Ar word Ic in
.Oo \&
.Op Sy \&(
.Ar pattern Oo \&| Ar pattern Oc No ... Sy \&)
.Ar list Sy ;;
.Oc No ...
.Ic esac
.Xc
.Pp
A
.Ic case
command executes the
.Ar list
associated with the first
.Ar pattern
that matches
.Ar word .
The form of the patterns is the same as that used for file name generation.
See
.Sx File Name Generation .
.Pp
The
.Sy \&;\&;
operator causes execution of
.Ic case
to terminate.
If
.Sy \&;&
is used in place of
.Sy \&;\&;
the next subsequent list, if any, is executed.
.Pp
.It Xo
.Ic if Ar list Ic ;then Ar list
.Op Ic ;elif Ar list Ic ;then Ar list
.No ...
.Op Ic ;else Ar list
.Ic ;fi
.Xc
.Pp
The
.Ar list
following
.Ic if
is executed and, if it returns a
.Sy zero
exit status, the
.Ar list
following the first
.Ic then
is executed.
Otherwise, the
.Ar list
following
.Ic elif
is executed, and, if its value is
.Sy zero ,
the
.Ar list
following the next
.Ic then
is executed.
Failing each successive
.Ic elif
.Ar list ,
the
.Ic else
.Ar list
is executed.
If the
.Ic if
.Ar list
has
.Sy non-zero
exit status and there is no
.Ic else
.Ar list ,
then the
.Ic if
command returns a
.Sy zero
exit status.
.Pp
.It Ic while Ar list Ic ;do Ar list Ic ;done
.It Ic until Ar list Ic ;do Ar list Ic ;done
.Pp
A
.Ic while
command repeatedly executes the while
.Ar list
and, if the exit status of the last command in the list is zero, executes the
.Ic do
.Ar list ,
otherwise the loop terminates.
If no commands in the
.Ic do
.Ar list
are executed, then the
.Ic while
command returns a
.Sy zero
exit status.
.Ic until
can be used in place of
.Ic while
to negate the loop termination test.
.Pp
.It Sy (( Ns Ar expression Ns Sy ))
.Pp
The
.Ar expression is evaluated using the rules for arithmetic evaluation described
in this manual page.
If the value of the arithmetic expression is
.Sy non-zero ,
the exit status is
.Sy 0 .
Otherwise the exit status is
.Sy 1 .
.Pp
.It Sy \&( Ns Ar list Ns Sy \&)
.Pp
Execute
.Ar list
in a separate environment.
If two adjacent open parentheses are needed for nesting, a SPACE must be
inserted to avoid evaluation as an arithmetic command as described in this
section.
.Pp
.It Sy { Ar list Ns Sy ;}
.Pp
.Ar list
is simply executed.
Unlike the metacharacters,
.Sy \&(
and
.Sy \&) ,
.Sy \&{
and
.Sy \&}
are
.Sy reserved words
and must occur at the beginning of a line or after a
.Sy \&;
to be recognized.
.Pp
.It Sy [[ Ar expression Sy ]]
.Pp
Evaluates
.Ar expression
and returns a
.Sy zero
exit status when
.Ar expression
is true.
See
.Sx Conditional Expressions
for a description of
.Ar expression .
.Pp
.It Ic function Ar varname Sy { Ar list Sy ;}
.It Ar varname Sy \&() Sy { Ar list Sy ;}
.Pp
Define a function which is referenced by
.Ar varname .
A function whose
.Ar varname
contains a dot
.Pq Sy \&.
is called a discipline function and the portion of the
.Ar varname
preceding the last
.Sy \&.
must refer to an existing variable.
.Pp
The body of the function is the
.Ar list
of commands between
.Sy {
and
.Sy } .
A function defined with the
.Ic function
.Ar varname
syntax can also be used as an argument to the
.Sy \&.
special built-in command to get the equivalent behavior as if the
.Ar varname
.Sy ()
syntax were used to define it.
See
.Sx Functions .
.Pp
.It Ic namespace Ar identifier Sy { Ar list Sy };
.Pp
Defines or uses the name space
.Ar identifier
and runs the commands in
.Ar list
in this name space.
See
.Sx Name Spaces .
.Pp
.It Ic time Op Ar pipeline
.Pp
If
.Ar pipeline
is omitted, the user and system time for the current shell and completed child
processes is printed on standard error.
Otherwise,
.Ar pipeline
is executed and the elapsed time as well as the user and system time are
printed on standard error.
The
.Ev TIMEFORMAT
variable can be set to a format string that specifies how the timing
information should be displayed.
See
.Sx Shell Variables
for a description of the
.Ev TIMEFORMAT
variable.
.El
.Pp
The following reserved words are recognized as reserved only when they are the
first word of a command and are not quoted:
.Bl -column -offset Ds xxxxxxxxxxx xxxxxxxxxxx xxxxxxxxxxx xxxxxxxxxxx
.It Cm case Ta Cm do Ta Cm done Ta Cm else
.It Cm elif Ta Cm esac Ta Cm for Ta Cm fi
.It Cm function Ta Cm if Ta Cm select Ta Cm then
.It Cm time Ta Cm until Ta Cm while Ta Sy { }
.It Sy [[ ]] Ta Sy \&! Ta Ta
.El
.Ss "Variable Assignments"
One or more variable assignments can start a simple command or can be arguments
to the
.Ic typeset ,
.Ic enum ,
.Ic export , or
.Ic readonly
special built-in commands.
The syntax for an
.Ar assignment
is of the form:
.Pp
.Bl -tag -width Ds -compact
.Sm off
.It Ar varname Sy = Ar word
.It Ar varname Oo Ar word Oc Sy = Ar word
.Sm on
.Pp
No space is permitted between
.Ar varname
and the
.Sy \&=
or between
.Sy \&=
and
.Ar word .
The variable
.Ar varname
is unset before the assignment.
.Pp
.Sm off
.It Ar varname Sy =( Ar assignlist Sy \&)
.Sm on
.Pp
No space is permitted between
.Ar varname
and the
.Sy = .
An
.Ar assignlist
can be one of the following:
.Bl -tag -width Ds
.It Ar word No ...
.Pp
Indexed array assignment.
.Sm off
.It Oo Ar word Oc Sy = Ar word \  No ...
.Sm on
.Pp
Associative array assignment.
If prefixed by
.Ic typeset Fl a ,
creates an indexed array instead.
.It Ar assignment No ...
.Pp
Compound variable assignment.
This creates a compound variable
.Ar varname
with sub-variables of the form
.Ar varname.name ,
where
.Ar name
is the name
portion of assignment.
The value of
.Ar varname
contains all the assignment elements.
Additional assignments made to sub-variables of
.Ar varname
are also displayed as part of the value of
.Ar varname .
If no
.Ar assignment Ns No s
are specified,
.Ar varname
is a compound variable allowing subsequence child elements to be defined.
.It Ic typeset Oo Ar options Oc Ar assignment No ...
.Pp
Nested variable assignment.
Multiple assignments can be specified by separating each of them with a
.Sy \&; .
The previous value is unset before the assignment.
.It Ic \&. Ar filename
.Pp
Include the assignment commands contained in
.Ar filename .
.El
.Pp
In addition, a
.Sy +=
can be used in place of the
.Sy \&=
to signify adding to or appending to the previous value.
When
.Sy +=
is applied to an arithmetic type,
.Ar word
is evaluated as an arithmetic expression and added to the current value.
When applied to a string variable, the value defined by
.Ar word
is appended to the value.
For compound assignments, the previous value is not unset and the new values
are appended to the current ones provided that the types are compatible.
The right hand side of a variable assignment undergoes all the expansion listed
below except word splitting, brace expansion, and file name generation.
When the left hand side is an assignment is a compound variable and the right
hand is the name of a compound variable, the compound variable on the right
will be copied or appended to the compound variable on the left.
.El
.Ss "Comments"
A word beginning with
.Ic #
causes that word and all the following characters up to a NEWLINE to be
commented, or ignored.
.Ss "Aliasing"
The first word of each command is replaced by the text of an alias if an alias
for this word has been defined.
An alias name consists of any number of characters excluding metacharacters,
quoting characters, file expansion characters, parameter expansion characters,
command substitution characters, the characters
.Sy /
and
.Sy = .
The replacement string can contain any valid shell script including the
metacharacters listed in the
.Sx Commands
section.
The first word of each command in the replaced text, other than any that are in
the process of being replaced, are tested for aliases.
If the last character of the alias value is a BLANK then the word following the
alias is also checked for alias substitution.
.Pp
Aliases can be used to redefine built-in commands but cannot be used to
redefine the reserved words listed in the
.Sx Commands
section.
Aliases can be created and listed with the
.Ic alias
command and can be removed with the
.Ic unalias
command.
.Pp
Aliasing is performed when scripts are read, not while they are executed.
For an alias to take effect, the
.Ic alias
definition command has to be executed before the command which references the
alias is read.
The following aliases are compiled into the shell but can be unset or
redefined:
.Bd -literal -offset Ds
autoload='typeset -fu'
command='command '
compound='typeset -C'
fc=hist
float='typeset -lE'
functions='typeset -f'
hash='alias -t --'
history='hist -l'
integer='typeset -li'
nameref='typeset -n'
nohup='nohup '
r='hist -s'
redirect='command exec'
source='command .'
stop='kill -s STOP'
suspend='kill -s STOP $$'
times='{ { time;} 2>&1;}'
type='whence -v'
.Ed
.Ss "Tilde Substitution"
After alias substitution is performed, each word is checked to see if it begins
with an unquoted tilde
.Pq Sy \&~ .
For tilde substitution,
.Ar word
also refers to the
.Ar word
portion of parameter expansion.
See
.Sx Parameter Expansion .
.Pp
If it does, the word up to a
.Sy /
is checked to see if it matches a user name in the password database.
If a match is found, the
.Sy ~
and the matched login name are replaced by the login directory of the matched
user.
If no match is found, the original text is left unchanged.
A
.Sy ~
by itself, or in front of a
.Sy / ,
is replaced by
.Ev $HOME .
A
.Sy ~
followed by a
.Sy +
or
.Sy -
is replaced by the value of
.Ev $PWD
and
.Ev $OLDPWD
respectively.
.Pp
In addition, when expanding a
.Ar variable assignment ,
tilde substitution is attempted when the value of the assignment begins with a
.Sy ~ ,
and when a
.Sy ~
appears after a colon
.Pq Sy \&: .
The
.Sy \&:
also terminates a
.Sy ~
login name.
.Ss "Command Substitution"
The standard output from a command enclosed in parentheses preceded by a dollar
sign -
.Sy \&$ Ns Po Ar list Pc -
or in a brace group preceded by a dollar
sign -
.Sy \&${ Ar list Ns Sy ;} ,
- or in a pair of grave accents -
.Sy ``
- can be used as part or all of a word.
Trailing NEWLINEs are removed.
In the second case, the
.Sy {
and
.Sy }
are treated as a reserved words so that
.Sy {
must be followed by a blank and
.Sy }
must appear at the beginning of
the line or follow a
.Sy \&; .
In the third (obsolete) form, the string between the quotes is processed for
special quoting characters before the command is executed.
See
.Sx Quoting .
.Pp
The command substitution
.Sy $(cat file)
can be replaced by the equivalent
but faster
.Sy $(<file) .
The command substitution
.Sy $( Ns Ar n Sy \&<\&#\&)
expands to the current byte offset for file descriptor
.Ar n .
Except for the second form, the command list is run in a subshell so that no
side effects are possible.
For the second form, the final
.Sy }
will be recognized as a reserved word after any token.
.Ss "Arithmetic Substitution"
An arithmetic expression enclosed in double parentheses preceded by a dollar
sign -
.Sy $(( Ns Ar arithmetic_expression Ns Sy ))
- is replaced by the value of the arithmetic expression within the double
parentheses.
.Ss "Process Substitution"
Each command argument of the form
.Sy <( Ns Ar list Ns Sy \&)
or
.Sy >( Ns Ar list Ns Sy \&)
runs process
.Ar list
asynchronously connected to some file in
.Pa /dev/fd .
The name of this file becomes the argument to the command.
If the form with
.Sy >
is selected then writing on this file provides input for
.Ar list .
If
.Sy <
is used, then the file passed as an argument contains the output of the
.Ar list
process.
.Pp
For example,
.Bd -literal -offset Ds
paste <(cut -f1 file1) <(cut -f3 file2) | tee \e
    >(process1) >(process2)
.Ed
.Pp
.Sy cut Ns No s
fields 1 and 3 from the files
.Ar file1
and
.Ar file2
respectively,
.Sy paste Ns No s
the results together, and sends it to the processes
.Ar process1
and
.Ar process2 .
It also displays the results to the standard output.
The file, which is passed as an argument to the command, is a UNIX
.Xr pipe 2 .
Programs that expect to
.Xr lseek 2
on the file do not work.
.Pp
Process substitution of the form
.Sy <( Ns Ar list Ns Sy \&)
can also be used
with the
.Sy <
redirection operator which causes the output of list to be standard input or
the input for whatever file descriptor is specified.
.Ss "Parameter Expansion"
A parameter is a variable, one or more digits, or any of the characters
.Sy \&* ,
.Sy \&@ ,
.Sy \&# ,
.Sy \&? ,
.Sy \&- ,
.Sy \&$ ,
and
.Sy \&! .
A variable is denoted by a
.Ar vname .
To create a variable whose
.Ar vname
contains a
.Sy \&. ,
a variable whose
.Ar vname
consists of everything before the last
.Sy \&.
must already exist.
A variable has a value and zero or more attributes.
Variables can be assigned values and attributes by using the
.Ic typeset
special built-in command.
The attributes supported by the shell are described later with the
.Ic typeset
special built-in command.
Exported variables pass values and attributes to the environment.
.Pp
The shell supports both indexed and associative arrays.
An element of an array variable is referenced by a subscript.
A subscript for an indexed array is denoted by an arithmetic expression,
.Pq see Sx Arithmetic Evaluation ,
between a
.Sy \&[
and a
.Sy \&] .
To assign values to an indexed array, use
.Ar vname Ns Sy =( Ns Ar value No ... Ns Sy \&)
or
.Sy set Fl A Ar vname value No ... .
The value of all subscripts must be in the range of
.Sy 0
to
.Sy 4,194,303 .
A negative subscript is treated as an offset from the maximum current index +1
so that -1 refers to the last element.
Indexed arrays can be declared with the
.Fl a
option to
.Ic typeset .
Indexed arrays need not be declared.
Any reference to a variable with a valid subscript is legal and an array will
be created if necessary.
.Pp
An associative array is created with the
.Fl A
option to
.Ic typeset .
A subscript for an associative array is denoted by a string enclosed between
.Sy \&[
and
.Sy \&] .
.Pp
Referencing any array without a subscript is equivalent to referencing the
array with subscript
.Sy 0 .
.Pp
The value of a variable can be assigned by:
.Bd -ragged -offset Ds
.Ar vname Ns Sy = Ns Ar value
.Op Ar vname Ns Sy = Ns Ar value
.No \&...
.Ed
.Pp
or
.Bd -ragged -offset Ds
.Ar vname Ns [ Ns Ar subscript Ns ]= Ns Ar value
.Op Ar vname Ns [ Ns Ar subscript Ns ]= Ns Ar value
.No ...
.Ed
.Pp
Note that no space is allowed before or after the
.Sy = .
.Pp
Attributes assigned by the
.Ic typeset
special built-in command apply to all elements of the array.
An array element can be a simple variable, a compound variable or an array
variable.
An element of an indexed array can be either an indexed array or an associative
array.
An element of an associative array can also be either.
To refer to an array element that is part of an array element, concatenate the
subscript in brackets.
For example, to refer to the
.Ar foobar
element of an associative array that is defined as the third element of the
indexed array, use
.Sm off
.Sy ${ Ar vname Sy \&[ Ar 3 Sy ][ Ar foobar Sy ]} .
.Sm on
.Pp
A
.Ar nameref
is a variable that is a reference to another variable.
A
.Ar nameref
is created with the
.Fl n
attribute of
.Ic typeset .
The value of the variable at the time of the
.Ic typeset
command becomes the variable that is referenced whenever the
.Ar nameref
variable is used.
The name of a
.Ar nameref
cannot contain a dot
.Pq \&. .
When a variable or
function name contains a dot
.Pq \&.
and the portion of the name up to the first \&. matches the name of a
.Ar nameref ,
the variable referred to is obtained by replacing the
.Ar nameref
portion with the name of the variable referenced by the
.Ar nameref .
If a
.Ar nameref
is used as the index of a
.Cm for
loop, a name reference is established for each item in the list.
A
.Ar nameref
provides a convenient way to refer to the variable inside a function whose name
is passed as an argument to a function.
For example, if the name of a variable is passed as the first argument to a
function, the command
.Bd -literal -offset Ds
typeset -n var=$1
.Ed
.Pp
inside the function causes references and assignments to
.Ar var
to be references and assignments to the variable whose name has been passed to
the function.
If any of the floating point attributes,
.Fl E ,
.Fl F
or
.Fl X ,
or the integer attribute,
.Fl i ,
is set for
.Ar vname ,
then the
.Ar value
is subject to arithmetic evaluation as described in this manual page.
Positional parameters, parameters denoted by a number, can be assigned values
with the
.Cm set
special built-in command.
Parameter
.Sy $0
is set from argument zero when the shell is invoked.
.Pp
The character
.Sy $
is used to introduce substitutable parameters.
.Pp
.Bl -tag -width Ds -compact
.It Sy ${ Ns Ar parameter Ns Sy }
The shell reads all the characters from
.Sy ${
to the matching
.Sy }
as part of the same word even if it contains braces or metacharacters.
The value, if any, of the parameter is substituted.
The braces are required when
.Ar parameter
is followed by a letter, digit, or underscore that is not to be interpreted as
part of its name or when the variable name contains a dot
.Pq Sy \&. .
The braces are also required when a variable is subscripted unless it is part
of an Arithmetic Expression or a Conditional Expression.
If
.Ar parameter
is one or more digits then it is a positional parameter.
A positional parameter of more than one digit must be enclosed in braces.
If
.Ar parameter
is
.Sy \&*
or
.Sy \&@ ,
then all the positional parameters, starting with
.Sy $1 ,
are substituted and separated by a field separator character.
If an array
.Ar vname
with last subscript
.Sy \&*
or
.Sy \&@
is used, or for index arrays of the form
.Ar sub1 Ns Sy \&.. Ns Ar sub2
is used, then the value for each of the elements between
.Ar sub1
and
.Ar sub2
inclusive
.Pq or all elements for Sy \&* and Sy \&@
is substituted, separated by the first character of the value of
.Ev IFS .
.Pp
.It Sy ${# Ns Ar parameter Ns Sy }
If
.Ar parameter
is
.Sy \&*
or
.Sy \&@ ,
the number of positional parameters is substituted.
Otherwise, the length of the value of the
.Ar parameter
is substituted.
.Pp
.It Sy ${# Ns Ar vname Ns Sy [*]}
.It Sy ${# Ns Ar vname Ns Sy [@]}
The number of elements in the array
.Ar vname
is substituted.
.Pp
.It Sy ${@ Ns Ar vname Ns Sy }
Expands to the type name or attributes of the variable referred to by
.Ar vname .
See
.Sx Type Variables .
.Pp
.It Sy \&$\&{\&! Ns Ar vname Ns Sy }
Expands to the name of the variable referred to by
.Ar vname .
This is
.Ar vname
except when
.Ar vname
is a name reference.
.Pp
.It Sy \&$\&{\&! Ns Ar vname Ns Oo Ar subscript Oc Ns Sy }
Expands to name of the subscript unless
.Ar subscript
is
.Sy \&*
or
.Sy \&@ ,
or of the form
.Ar sub1 Ns Sy \&.. Ns Ar sub2 .
When
.Ar subscript
is
.Sy \&* ,
the list of array subscripts for
.Ar vname
is generated.
For a variable that is not an array, the value is
.Sy 0
if the variable is set, otherwise it is
.Sy null .
When
.Ar subscript
is
.Sy \&@ ,
it is the same as
.Sy ${ Ar vname Ns Oo * Oc Ns Sy } ,
except that when used in double quotes, each array subscript yields a separate
argument.
When subscript is of the form
.Ar sub1 Ns Sy \&.. Ns Ar sub2
it expands to the list of subscripts between
.Ar sub1
and
.Ar sub2
inclusive using the same quoting rules as
.Sy @ .
.Pp
.It Sy \&$\&{\&! Ns Ar prefix Ns Sy *}
Expands to the names of the variables whose names begin with
.Ar prefix .
.Pp
.It Sy ${ Ns Ar parameter Ns Sy \&:- Ns Ar word Ns Sy }
If
.Ar parameter
is set and is non-null then substitute its value.
Otherwise substitute
.Ar word .
.Pp
.It Sy ${ Ns Ar parameter Ns Sy \&:= Ns Ar word Ns Sy }
If
.Ar parameter
is not set or is
.Sy null ,
set it to
.Ar word .
The value of the parameter is then substituted.
Positional parameters cannot be assigned to in this way.
.Pp
.It Sy ${ Ns Ar parameter Ns Sy \&:\&? Ns Ar word Ns Sy }
If
.Ar parameter
is set and is non-null, substitute its value.
Otherwise, print
.Ar word
and exit from the shell, if the shell is not interactive.
If
.Ar word
is omitted then a standard message is printed.
.Pp
.It Sy ${ Ns Ar parameter Ns Sy \&:+ Ns Ar word Ns Sy }
If
.Ar parameter
is set and is non-null, substitute
.Ar word .
Otherwise substitute nothing.
.El
.Pp
In the above,
.Ar word
is not evaluated unless it is to be used as the substituted string.
In the following example,
.Ic pwd
is executed only if
.Sy d
is not set or is
.Dv NULL :
.Bd -literal -offset Ds
print ${d:-$(pwd)}
.Ed
.Pp
If the colon
.Pq Sy \&:
is omitted from the expression, the shell only checks whether
.Ar parameter
is set or not.
.Pp
.Bl -tag -width Ds -compact
.Sm off
.It Sy ${ Ns Ar parameter Sy \&: Ar offset Sy \&: Ar length Sy }
.It Sy ${ Ns Ar parameter Sy \&: Ar offset Sy }
.Sm on
Expands to the portion of the value of
.Ar parameter
starting at the
character
.Pq counting from 0
determined by expanding
.Ar offset
as an arithmetic expression and consisting of the number of characters
determined by the arithmetic expression defined by
.Ar length .
.Pp
In the second form, the remainder of the value is used.
A negative offset counts backwards from the end of
.Ar parameter .
.Pp
One or more BLANKs is required in front of a minus sign to prevent the shell
from interpreting the operator as
.Sy \&:- .
If parameter is
.Sy \&*
or
.Sy \&@ ,
or is an array name indexed by
.Sy \&*
or
.Sy \&@ ,
then
.Ar offset
and
.Ar length
refer to the array index and number of elements respectively.
A negative
.Ar offset
is taken relative to one greater than the highest subscript for indexed arrays.
The order for associative arrays is unspecified.
.Pp
.Sm off
.It Sy ${ Ns Ar parameter Sy # Ar pattern Sy }
.It Sy ${ Ns Ar parameter Sy ## Ar pattern Sy }
.Sm on
If the shell
.Ar pattern
matches the beginning of the value of
.Ar parameter ,
then the value of this expansion is the value of the
.Ar parameter
with the matched portion deleted.
Otherwise the value of this
.Ar parameter
is substituted.
In the first form the smallest matching
.Ar pattern
is deleted and in the second form the largest matching
.Ar pattern
is deleted.
When
.Ar parameter
is
.Sy \&@ ,
.Sy \&* ,
or an array variable with subscript
.Sy \&@
or
.Sy \&* ,
the substring operation is applied to each element in turn.
.Pp
.Sm off
.It Sy ${ Ns Ar parameter Sy % Ar pattern Sy }
.It Sy ${ Ns Ar parameter Sy %% Ar pattern Sy }
.Sm on
If the shell
.Ar pattern
matches the end of the value of
.Ar parameter ,
then the value of this expansion is the value of the parameter with the matched
part deleted.
Otherwise substitute the value of
.Ar parameter .
In the first form the smallest matching pattern is deleted, and in the second
form the largest matching pattern is deleted.
When parameter is
.Sy \&@ ,
.Sy \&* ,
or an array variable with subscript
.Sy \&@
or
.Sy \&* ,
the substring operation is applied to each element in turn.
.Pp
.Sm off
.It Sy ${ Ns Ar parameter Sy / Ar pattern Sy / Ar string Sy }
.It Sy ${ Ns Ar parameter Sy // Ar pattern Sy / Ar string Sy }
.It Sy ${ Ns Ar parameter Sy /# Ar pattern Sy / Ar string Sy }
.It Sy ${ Ns Ar parameter Sy /% Ar pattern Sy / Ar string Sy }
.Sm on
Expands
.Ar parameter
and replaces the longest match of
.Ar pattern
with the specified
.Ar string .
Each occurrence of
.Sy \e Ns Ar n
in
.Ar string
is replaced by the portion of
.Ar parameter
that matches the
.Ar n Ns No th
sub-pattern.
.Pp
When
.Ar string
is null, the
.Ar pattern
is deleted and the
.Sy /
in front of string can be omitted.
When
.Ar parameter
is
.Sy \&@ ,
.Sy \&* ,
or an
array variable with subscript
.Sy \&@
or
.Sy \&* ,
the substitution operation is applied to each element in turn.
In this case, the
.Ar string
portion of
.Ar word
is re-evaluated for each element.
.Pp
In the first form, only the first occurrence of
.Ar pattern
is replaced.
.Pp
In the second form, each match for
.Ar pattern
is replaced by the specified
.Ar string .
.Pp
The third form restricts the pattern match to the beginning of the
.Ar string .
.Pp
The fourth form restricts the pattern match to the end of the
.Ar string .
.El
.Pp
The following parameters are automatically set by the shell:
.Bl -tag -width Ds
.It Sy #
The number of positional parameters in decimal.
.It Sy -
Options supplied to the shell on invocation or by the
.Ic set
command.
.It Sy \&?
The decimal value returned by the last executed command.
.It Sy $
The process number of this shell.
.It Sy _
Initially, the value of
.Sy _
is the absolute pathname of the shell or script being executed as passed in the
environment.
It is subsequently assigned the last argument of the previous command.
.Pp
This parameter is not set for commands which are asynchronous.
This parameter is also used to hold the name of the matching
.Ev MAIL
file when checking for mail.
.It Sy \&!
The process id or the pool name and job number of the last background command
invoked or the most recent job put in the background with the
.Ic bg
built-in command.
Background jobs started in a named pool with be in the form
.Ar pool Ns \&. Ns Ar number
where
.Ar pool
is the pool name and
.Ar number
is the job number within that pool.
.It Sy \&.sh.command
When processing a
.Dv DEBUG
trap, this variable contains the current command line that is about to run.
.It Sy \&.sh.edchar
This variable contains the value of the keyboard character (or sequence of
characters if the first character is an ESC,
.Pq  ASCII 033
that has been entered when processing a
.Dv KEYBD
trap.
If the value is changed as part of the trap action, then the new value replaces
the key (or key sequence) that caused the trap.
See the
.Sx Key Bindings
section of this manual page.
.It Sy \&.sh.edcol
The character position of the cursor at the time of the most recent
.Dv KEYBD
trap.
.It Sy \&.sh.edmode
The value is set to ESC when processing a
.Dv KEYBD
trap while in
.Sy vi
insert mode.
Otherwise,
.Sy \&.sh.edmode
is null when processing a
.Dv KEYBD
trap.
See the
.Sx vi Editing Mode
section of this manual page.
.It Sy \&.sh.edtext
The characters in the input buffer at the time of the most recent
.Dv KEYBD
trap.
The value is null when not processing a
.Dv KEYBD
trap.
.It Sy \&.sh.file
The pathname of the file than contains the current command.
.It Sy \&.sh.fun
The name of the current function that is being executed.
.It Sy \&.sh.match
An indexed array which stores the most recent match and sub-pattern matches
after conditional pattern matches that match and after variables expansions
using the operators
.Sy \&# ,
.Sy \&% , or
.Sy \&/ .
The
.Sy 0 Ns No th
element stores the complete match and the
.Ar i Ns No th
element stores the
.Ar i Ns No th
sub-match.
The
.Sy \&.sh.match
variable is unset when the variable that has expanded is assigned a new value.
.It Sy \&.sh.math
Used for defining arithmetic functions
.Pq see Sx Arithmetic evaluation
and stores the list of user-defined arithmetic functions.
.It Sy \&.sh.name
Set to the name of the variable at the time that a discipline function is
invoked.
.It Sy \&.sh.subscript
Set to the name subscript of the variable at the time that a discipline
function is invoked.
.It Sy \&.sh.subshell
The current depth for sub-shells and command substitution.
.It Sy \&.sh.value
Set to the value of the variable at the time that the set or append discipline
function is invoked.
When a user-defined arithmetic function is invoked, the value of
.Sy .sh.value
is saved and
.Sy .sh.value
is set to long double precision floating point.
.Sy .sh.value
is restored when the function returns.
.It Sy \&.sh.version
Set to a value that identifies the version of this shell.
.It Sy LINENO
The current line number within the script or function being executed.
.It Sy OLDPWD
The previous working directory set by the
.Ic cd
command.
.It Sy OPTARG
The value of the last option argument processed by the
.Ic getopts
built-in command.
.It Sy OPTIND
The index of the last option argument processed by the
.Ic getopts
built-in command.
.It Sy PPID
The process number of the parent of the shell.
.It Sy PWD
The present working directory set by the
.Ic cd
command.
.It Sy RANDOM
Each time this variable is referenced, a random integer, uniformly distributed
between
.Sy 0
and
.Sy 32767 ,
is generated.
The sequence of random numbers can be initialized by assigning a numeric value
to
.Ev RANDOM .
.It Sy REPLY
This variable is set by the
.Ic select
statement and by the
.Ic read
built-in command when no arguments are supplied.
.It Sy SECONDS
Each time this variable is referenced, the number of seconds since shell
invocation is returned.
If this variable is assigned a value, then the value returned upon reference is
the value that was assigned plus the number of seconds since the assignment.
.It Sy SHLVL
An integer variable the is incremented each time the shell is invoked and is
exported.
If
.Ev SHLVL
is not in the environment when the shell is invoked, it is set to 1.
.El
.Pp
The following variables are used by the shell:
.Bl -tag -width Ds
.It Sy CDPATH
Defines the search path for the
.Ic cd
command.
.It Sy COLUMNS
Defines the width of the edit window for the shell edit modes and for printing
select lists.
.It Sy EDITOR
If the
.Ev VISUAL
variable is not set, the value of this variable is checked for the patterns as
described with
.Ev VISUAL
and the corresponding editing option is turned on.
.Pp
See the
.Ic set
command in the
.Sx Special Commands
section of this manual page.
.It Sy ENV
Performs parameter expansion, command substitution, and arithmetic substitution
on the value to generate the pathname of the script that is executed when the
shell is invoked.
This file is typically used for alias and function definitions.
The default value is
.Sy $HOME/.kshrc .
.Pp
See the
.Sx Invocation
section of this manual page.
.Pp
.Ev ENV
is not set by the shell.
.It Sy FCEDIT
Obsolete name for the default editor name for the
.Ic hist
command.
.Ev FCEDIT
is not used when
.Ev HISTEDIT
is set.
.Pp
The shell specifies a default value to
.Ev FCEDIT .
.It Sy FIGNORE
A pattern that defines the set of file names that is ignored when performing
file name matching.
.It Sy FPATH
The search path for function definitions.
The directories in this path are searched for a file with the same name as the
function or command when a function with the
.Fl u
attribute is referenced and when a command is not found.
If an executable file with the name of that command is found, then it is read
and executed in the current environment.
Unlike
.Ev PATH ,
the current directory must be represented explicitly by dot
.Pq Sy \&.
rather than by adjacent colon
.Pq Sy \&:
characters or a beginning or ending colon
.Pq Sy \&: .
.It Sy HISTCMD
The number of the current command in the history file.
.It Sy HISTEDIT
The name for the default editor name for the
.Ic hist
command.
.It Sy HISTFILE
If this variable is set when the shell is invoked, the value is the pathname of
the file that is used to store the command history.
See the
.Sx Command Re-entry
section of this manual page.
.It Sy HISTSIZE
If this variable is set when the shell is invoked, then the number of
previously entered commands that are accessible by this shell is greater than
or equal to this number.
The default is
.Sy 512 .
.It Sy HOME
The default argument (home directory) for the
.Ic cd
command.
.Pp
.Ev HOME
is not set by the shell.
.Ev HOME
is set by
.Xr login 1 .
.It Sy IFS
Internal field separators, normally SPACE, TAB, and NEWLINE that are used to
separate the results of command substitution or parameter expansion and to
separate fields with the built-in command read.
The first character of the
.Ev IFS
variable is used to separate arguments for the
.Dq Sy \&$*
substitution.
See the
.Sx Quoting
section of this manual page.
.Pp
Each single occurrence of an
.Ev IFS
character in the string to be split, that is not in the
.Sy issspace
character class, and any adjacent characters in
.Ev IFS
that are in the
.Sy issspace
character class, delimit a field.
One or more characters in
.Ev IFS
that belong to the
.Sy issspace
character class, delimit a field.
In addition, if the same
.Sy issspace
character appears consecutively inside
.Ev IFS ,
this character is treated as if it were not in the
.Sy issspace
class, so that if
.Ev IFS
consists of two tab characters, then two adjacent tab characters delimit a null
field.
.Pp
The shell specifies a default value to
.Ev IFS .
.It Sy JOBMAX
This variable defines the maximum number running background jobs that can run
at a time.
When this limit is reached, the shell will wait for a job to complete before
starting a new job.
.It Sy LANG
This variable determines the locale category for any category not specifically
selected with a variable starting with
.Ev LC_
or
.Ev LANG .
.It Sy LC_ALL
This variable overrides the value of the
.Ev LANG
variable and any other
.Ev LC_
variable.
.It Sy LC_COLLATE
This variable determines the locale category for character collation
information.
.It Sy LC_CTYPE
This variable determines the locale category for character handling functions.
It determines the character classes for pattern matching.
See the
.Sx File Name Generation
section of this manual page.
.It Sy LC_NUMERIC
This variable determines the locale category for the decimal point character.
.It Sy LINES
If this variable is set, the value is used to determine the column length for
printing select lists.
Select lists prints vertically until about two-thirds of
.Ev LINES
lines are filled.
.It Sy MAIL
If this variable is set to the name of a mail file
.Em and
the
.Ev MAILPATH
variable is not set, then the shell informs the user of arrival of mail in the
specified file.
.Pp
.Ev MAIL
is not set by the shell.
On some systems,
.Ev MAIL
is set by
.Xr login 1 .
.It Sy MAILCHECK
Specifies how often in seconds the shell checks for changes in the modification
time of any of the files specified by the
.Ev MAILPATH
or
.Ev MAIL
variables.
The default value is
.Sy 600
seconds.
When the time has elapsed the shell checks before issuing the next prompt.
.Pp
The shell specifies a default value to
.Ev MAILCHECK .
.It Sy MAILPATH
A colon
.Pq Sy \&:
separated list of file names.
If this variable is set, then the shell informs the user of any modifications
to the specified files that have occurred within the last
.Ev MAILCHECK
seconds.
Each file name can be followed by a
.Sy \&?
and a message that is printed.
The message undergoes parameter expansion, command substitution, and arithmetic
substitution with the variable
.Sy $_
defined as the name of the file that has changed.
The default message is
.Ql you have mail in $_ .
.It Sy PATH
The search path for commands.
Except in
.Pa .profile ,
users cannot change
.Ev PATH
if executing under
.Nm rksh93 .
See the
.Sx Execution section
of this manual page.
.Pp
The shell specifies a default value to
.Ev PATH .
.It Sy PS1
The value of this variable is expanded for parameter expansion, command
substitution, and arithmetic substitution to define the primary prompt string
which by default is
.Sy $ .
The character
.Sy \&!
in the primary prompt string is replaced by the command number.
Two successive occurrences of
.Sy \&!
produces a single
.Sy \&!
when the prompt string is printed.
See the
.Sx Command Re-entry
section of this manual page.
.Pp
The shell specifies a default value to
.Ev PS1 .
.It Sy PS2
Secondary prompt string, by default,
.Sy \&> .
.Pp
The shell specifies a default value to
.Ev PS2 .
.It Sy PS3
Selection prompt string used within a select loop, by default
.Sy \&\&#\&? .
.Pp
The shell specifies a default value to
.Ev PS3 .
.It Sy PS4
The value of this variable is expanded for parameter evaluation, command
substitution, and arithmetic substitution and precedes each line of an
execution trace.
By default,
.Ev PS4
is
.Sy \&+ .
When
.Ev PS4
is unset, the execution trace prompt is also
.Sy \&+ .
.Pp
The shell specifies a default value to
.Ev PS4 .
.It Sy SHELL
The pathname of the shell is kept in the environment.
At invocation, if the basename of this variable is
.Sy rsh ,
.Sy rksh ,
.Sy rksh93 ,
or
.Sy krsh ,
the shell becomes restricted.
.Pp
.Ev SHELL
is not set by the shell.
On some systems,
.Ev SHELL
is set by
.Xr login 1 .
.It Sy TIMEFORMAT
The value of this parameter is used as a format string specifying how the
timing information for pipelines prefixed with the
.Ic time
reserved word should be displayed.
The
.Sy \&%
character introduces a format sequence that is expanded to a time value or
other information.
.Pp
The format sequences and their meanings are as follows.
.Bl -tag -width Ar
.It Sy %%
A literal
.Sy % .
.Sm off
.It Sy % Oo Ar p Oc Oo Cm l Oc Cm R
The elapsed time in seconds.
.It Sy % Oo Ar p Oc Oo Cm l Oc Cm U
The number of CPU seconds spent in user mode.
.It Sy % Oo Ar p Oc Oo Cm l Oc Cm S
The number of CPU seconds spent in system mode.
.It Sy % Ns Cm P
The CPU percentage, computed as
.Sy (U + S) / R .
.Sm on
.El
.Pp
The braces denote optional portions.
The optional
.Ar p
is a digit specifying
the
.Ar precision ,
the number of fractional digits after a decimal point.
A value of
.Sy 0
causes no decimal point or fraction to be output.
At most three places after the decimal point can be displayed.
Values of
.Ar p
greater than
.Sy 3
are treated as
.Sy 3 .
If
.Ar p
is not specified, the value
.Sy 3
is used.
.Pp
The optional
.Cm l
specifies a longer format, including hours if greater than zero, minutes, and
seconds of the form
.Em HHhMMmSS.FFs .
The value of
.Ar p
determines whether or not the fraction is included.
.Pp
All other characters are output without change and a trailing NEWLINE is added.
If unset, the default value:
.Pp
.Dl $'\enreal\et%2lR\enuser\et%2lU\ensys%2lS'
.Pp
is used.
If the value is null, no timing information is displayed.
.It Sy TMOUT
If set to a value greater than zero,
.Ev TMOUT
is the default time-out value for the
.Ic read
built-in command.
The
.Ic select
compound command terminates after
.Ev TMOUT
seconds when input is from a terminal.
Otherwise, the shell terminates if a line is not entered within the prescribed
number of seconds while reading from a terminal.
The shell can be compiled with a maximum bound for this value which cannot be
exceeded.
.Pp
The shell specifies a default value to
.Ev TMOUT .
.It Sy VISUAL
If the value of this variable matches the pattern
.Sy *[Vv][Ii]* ,
then the
.Sy vi
option is turned on.
See
.Sx Special Commands .
If the value matches the pattern
.Sy *gmacs* ,
the
.Sy gmacs
option is turned on.
If the value matches the pattern
.Sy *macs* ,
then the
.Sy emacs
option is turned on.
The value of
.Ev VISUAL
overrides the value of
.Ev EDITOR .
.El
.Ss "Field Splitting"
After parameter expansion and command substitution, the results of
substitutions are scanned for the field separator characters
.Pq those found in Ev IFS
and split into distinct fields where such characters are found.
Explicit null fields
.Pq Sy "" or Sy \&''
are retained.
Implicit null fields, those resulting from parameters that have no values or
command substitutions with no output, are removed.
.Pp
If the
.Sy braceexpand
.Pq Fl B
option is set, each of the fields resulting from
.Ev IFS
are checked to see if they contain one or more of the brace patterns.
Valid brace patterns are:
.Pp
.Bl -item -offset Ds -compact
.Sm off
.It
.Brq Sy \&*,* Ns Oo Sy ,* Oc Ns No ...
.It
.Brq Ar l1 Sy \&.. Ar l2
.It
.Brq Ar n1 Sy \&.. Ar n2
.It
.Brq Ar n1 Sy \&.. Ar n2 Sy % Ar fmt
.It
.Brq Ar n1 Sy \&.. Ar n2 Sy \&.. Ar n3
.It
.Brq Ar n1 Sy \&.. Ar n2 Sy \&.. Ar n3 Sy % Ar fmt
.Sm on
.El
.Pp
where
.Sy *
represents any character,
.Ar l1 ,
.Ar l2
are letters and
.Ar n1 ,
.Ar n2 ,
.Ar n3
are signed numbers and
.Ar fmt
is a format specified as used by
.Ic printf .
In each case, fields are created by prepending the characters before the
.Sy {
and appending the characters after
the
.Sy }
to each of the strings generated by the characters between the
.Sy {
and
.Sy } .
The resulting fields are checked to see if they have any brace patterns.
.Pp
In the first form, a field is created for each string between
.Sy {
and the first comma
.Pq Sq \&, ,
between a pair of commas
.Pq Sq \&,
and between
the last comma
.Pq Sq \&,
and the terminating
.Sy } .
The string
represented by
.Sy *
can contain embedded matching { and } without quoting.
Otherwise, each
.Sy {
and
.Sy }
within
.Sy *
must be quoted.
.Pp
In the second form,
.Ar l1
and
.Ar l2
must both be either upper case or both be lower case characters in the C
locale.
In this case a field is created for each character from
.Ar l1
to
.Ar l2
inclusive.
.Pp
In the remaining forms, a field is created for each number starting at
.Ar n1 .
This continues until it reaches
.Ar n2
and increments
.Ar n1
by
.Ar n3 .
The cases where
.Ar n3
is not specified behave as if
.Ar n3
were 1 if
.Ar n1
<=
.Ar n2 ,
and -1 otherwise.
.Pp
In forms which specify
.Sy % Ns Ar fmt ,
any format flags, widths and precisions can be specified and
.Ar fmt
can end in any of the specifiers
.Sy cdiouxX .
For example,
.Sy {a,z}{1..5..3%02d}{b..c}x
expands to the 8 fields,
.Sy a01bx ,
.Sy a01cx ,
.Sy a04bx ,
.Sy a04cx ,
.Sy z01bx ,
.Sy z01cx ,
.Sy z04bx ,
and
.Sy z04cx .
.Ss "File Name Generation"
Following splitting, each field is scanned for the characters
.Sy \&* ,
.Sy \&? ,
.Sy \&( ,
and
.Sy \&[ ,
unless the
.Fl f
option has been set.
If one of these characters appears, then the word is regarded as a pattern.
.Pp
Each file name component that contains any pattern character is replaced with a
lexicographically sorted set of names that matches the pattern from that
directory.
If no file name is found that matches the pattern, then that component of the
file name is left unchanged unless the pattern is prefixed with
.Sy ~(N)
in which case it is removed.
If
.Ev FIGNORE
is set, then each file name component that matches the pattern defined by the
value of
.Ev FIGNORE
is ignored when generating the matching file names.
The names
.Sy \&.
and
.Sy \&..
are also ignored.
If
.Ev FIGNORE
is not set, the character
.Sy \&.
at the start of each file name component is ignored unless the first character
of the pattern corresponding to this component is the character
.Sy \&.
itself.
For other uses of pattern matching the
.Sy /
and
.Sy \&.
are not specially treated.
.Bl -tag -width Ds
.It Sy *
Match any string, including the null string.
When used for file name expansion, if the
.Sy globstar
option is on, two adjacent
.Sy * Ns No s
by themselves match all files and zero or more directories and subdirectories.
If the two adjacent
.Sy * Ns No s
are followed by a
.Sy / ,
only directories and subdirectories match.
.It Sy \&?
Matches any single character.
.It Sy [...]
Match any one of the enclosed characters.
A pair of characters separated by
.Sy -
matches any character lexically between the pair, inclusive.
If the first character following the opening
.Sy \&[
is a
.Sy \&!
or
.Sy ^ ,
any character not enclosed is matched.
A
.Sy -
can be included in the character set by putting it as the first or last
character.
Within
.Sy \&[
and
.Sy \&] ,
character classes can be specified with the syntax
.Sy [: Ns Ar class Ns Sy \&:\&]
where
.Ar class
is one of the following classes defined in the
.Sy ANSI-C
standard:
.Bl -column -offset indent xxxxxx xxxxxx xxxxxx xxxxxx xxxxxx xxxxxx
.It alnum Ta alpha Ta blank Ta cntrl Ta digit Ta graph
.It lower Ta print Ta punct Ta space Ta upper Ta word
.It xdigit Ta Ta Ta Ta Ta
.El
.Pp
.Ar word
is equivalent to
.Ar alnum
plus the character
.Sy _ .
Within
.Sy \&[
and
.Sy \&] ,
an equivalence class can be specified with the syntax
.Sy [= Ns Ar c Ns Sy =]
which matches all characters with the same primary collation weight (as defined
by the current locale) as the character
.Ar c .
Within
.Sy \&[
and
.Sy \&] ,
.Sm off
.Sy \&[ \&. Ar symbol Ns \&. Sy \&]
.Sm on
matches the collating symbol
.Ar symbol .
.El
.Pp
A
.Sy pattern-list
is a list of one or more patterns separated from each other with an
.Sy \&&
or
.Sy \&| .
An
.Sy \&&
signifies that all patterns must be matched whereas
.Sy \&|
requires that only one pattern be matched.
Composite patterns can be formed with one or more of the following
sub-patterns:
.Bl -tag -width xxxxxxxxxxxxxxxxxxxxx
.Sm off
.It Sy \&?( Ar pattern-list Sy \&)
Optionally matches any one of the specified patterns.
.It Sy \&*( Ar pattern-list Sy \&)
Matches zero or more occurrences of the specified patterns.
.It Sy \&+( Ar pattern-list Sy \&)
Matches one or more occurrences of the specified patterns.
.It Sy \&{ Ar n Sy \&} Sy \&( Ar pattern-list Sy \&)
.Sm on
Matches
.Ar n
occurrences of the specified patterns.
.Sm off
.It Sy \&{ Ar m Sy \&, Ar n Sy \&} Sy \&( Ar pattern-list Sy \&)
.Sm on
Matches from
.Ar m
to
.Ar n
occurrences of the specified patterns.
If
.Ar m
is omitted,
.Sy 0
is used.
If
.Ar n
is omitted at least
.Ar m
occurrences are matched.
.Sm off
.It Sy \&@( Ar pattern-list Sy \&)
Matches exactly one of the specified patterns.
.It Sy \&!( Ar pattern-list Sy \&)
Matches anything except one of the specified patterns.
.Sm on
.El
.Pp
By default, each pattern, or sub-pattern matches the longest string possible
consistent with generating the longest overall match.
If more than one match is possible, the one starting closest to the beginning
of the string is chosen.
However, for each of the compound patterns a
.Sy -
can be inserted in front
of the
.Sy \&(
to cause the shortest match to the specified
.Ar pattern-list
to be used.
.Pp
When
.Sy pattern-list
is contained within parentheses, the backslash
character
.Pq Sy \e
is treated specially even when inside a character class.
All
.Sy ANSI-C
character escapes are recognized and match the specified character.
In addition the following escape sequences are recognized:
.Bl -tag -width Ds
.It Sy \ed
Matches any character in the digit class.
.It Sy \eD
Matches any character not in the digit class.
.It Sy \es
Matches any character in the space class.
.It Sy \eS
Matches any character not in the space class.
.It Sy \ew
Matches any character in the word class.
.It Sy \eW
Matches any character not in the word class.
.El
.Pp
A pattern of the form
.Sy %( Ns Ar pattern-pairs Ns Sy \&)
is a sub-pattern that can be used to match nested character expressions.
Each
.Ar pattern-pair
is a two character sequence which cannot contain
.Sy \&&
or
.Sy \&| .
The first
.Ar pattern-pair
specifies the starting and ending characters for the match.
Each subsequent
.Ar pattern-pair
represents the beginning and ending characters of a nested group that is
skipped over when counting starting and ending character matches.
The behavior is unspecified when the first character of a
.Ar pattern-pair
is alphanumeric except for the following:
.Bl -tag -width Ds
.It Sy D
Causes the ending character to terminate the search for this pattern without
finding a match.
.It Sy E
Causes the ending character to be interpreted as an escape character.
.It Sy L
Causes the ending character to be interpreted as a quote character causing all
characters to be ignored when looking for a match.
.It Sy Q
Causes the ending character to be interpreted as a quote character causing all
characters other than any escape character to be ignored when looking for a
match.
.El
.Pp
.Sy %({}Q"E\e) ,
matches characters starting at
.Sy {
until the matching
.Sy }
is found not counting any
.Sy {
or
.Sy }
that is inside a double quoted string or preceded by the escape character
.Pq Sy \e .
Without the
.Sy {}
this pattern matches any C language string.
.Pp
Each sub-pattern in a composite pattern is numbered, starting at
.Sy 1 ,
by the location of the
.Sy \&(
within the pattern.
The sequence
.Sy \e Ns Ar n ,
where
.Ar n
is a single digit and
.Sy \e Ns Ar n ,
comes after the
.Ar n Ns No th
sub-pattern, matches the same string as the sub-pattern itself.
.Pp
A pattern can contain sub-patterns of the form
.Sm off
.Sy ~( Ar options Sy \&: Ar pattern-list Sy \&) ,
.Sm on
where either
.Ar options
or
.Sy \&: Ns Ar pattern-list
can be omitted.
Unlike the other compound patterns, these sub-patterns are not counted in the
numbered sub-patterns.
.Sy \&: Ns Ar pattern-list
must be omitted for options
.Sy F ,
.Sy G ,
.Sy N
and
.Sy V
below.
If
.Ar options
is present, it can consist of one or more of the following:
.Bl -tag -width Ds
.It Sy +
Enable the following options.
This is the default.
.It Sy -
Disable the following options.
.It Sy E
The remainder of the pattern uses extended regular expression syntax like the
.Xr egrep 1
command.
.It Sy F
The remainder of the pattern uses
.Xr fgrep 1
expression syntax.
.It Sy g
File the longest match (greedy).
This is the default.
.It Sy G
The remainder of the pattern uses basic regular expression syntax like the
.Xr grep 1
command.
.It Sy i
Treat the match as case insensitive.
.It Sy K
The remainder of the pattern uses shell pattern syntax.
This is the default.
.It Sy l
Left anchor the pattern.
.Pp
This is the default for
.Sy K
style patterns.
.It Sy N
This is ignored.
However, when it is the first letter and is used with file name generation, and
no matches occur, the file pattern expands to the empty string.
.It Sy r
Right anchor the pattern.
.Pp
This is the default for
.Sy K
style patterns.
.It Sy X
The remainder of the pattern uses augmented regular expression syntax.
.It Sy P
The remainder of the pattern uses
.Xr perl 1
regular expression syntax.
Not all perl regular expression syntax is currently implemented.
.It Sy V
The remainder of the pattern uses System V regular expression syntax.
.El
.Pp
If both
.Ar options
and
.Sy \&: Ns Ar pattern-list
are specified, then the options apply only to
.Ar pattern-list .
Otherwise, these options remain in effect until they are disabled by a
subsequent
.Sy ~(...)
or at the end of
the sub-pattern containing
.Sy ~(...) .
.Ss "Quoting"
Each of the metacharacters listed in the
.Sx Definitions
section of this manual page has a special meaning to the shell and causes
termination of a word unless quoted.
A character can be quoted, that is, made to stand for itself, by preceding it
with a backslash
.Pq Sy \e .
The pair
.Sy \eNEWLINE
is removed.
All characters enclosed between a pair of single quote marks
.Pq Sy ''
that is not preceded by a
.Sy $
are quoted.
A single quote cannot appear within the single quotes.
A single quoted string preceded by an unquoted
.Sy $
is processed as an
.Sy ANSI-C
string except for the following:
.Bl -tag -width Ar
.It Sy \e0
Causes the remainder of the string to be ignored.
.It Sy \ec Ns Ar x
Expands to the character
.No CTRL- Ns Ar x .
.It Sy \eC[\&. Ns Ar name Ns Sy \&.\&]
Expands to the collating element
.Ar name .
.It Sy \ee
Equivalent to the escape character
.Pq ASCII 033 .
.It Sy \eE
Equivalent to the escape character
.Pq ASCII 033 .
.El
.Pp
Inside double quote marks
.Pq Sy \&"" ,
parameter and command substitution occur and
.Sy \e
quotes the characters
.Sy \e ,
.Sy \&` ,
.Sy \&" ,
and
.Sy \&$ .
A
.Sy \&$
in front of a double quoted string is ignored in the
.Dv C
or
.Dv POSIX
locale, and might cause the string to be replaced by a locale specific string
otherwise.
The meaning of
.Sy $*
and
.Sy $@
is identical when not quoted or when used as a variable assignment value or as
a file name.
However, when used as a command argument,
.Sy \&"$*"
is equivalent to
.Sm off
.Sy \&"$1 Ar d Sy $2 Ar d No ..." ,
.Sm on
where
.Ar d
is the first character of the
.Ev IFS
variable, whereas
.Sy \&"$@"
is equivalent to
.Sy \&"$1" \&"$2" No ...
Inside grave quote marks
.Pq Sy `` ,
.Sy \e
quotes the characters
.Sy \e ,
.Sy ` ,
and
.Sy $ .
If the grave quotes occur within double quotes, then
.Sy \e
also quotes the character
.Sy \&" .
.Pp
The special meaning of reserved words or aliases can be removed by quoting any
character of the reserved word.
The recognition of function names or built-in command names cannot be altered
by quoting them.
.Ss "Arithmetic Evaluation"
The shell performs arithmetic evaluation for arithmetic substitution, to
evaluate an arithmetic command, to evaluate an indexed array subscript, and to
evaluate arguments to the built-in commands
.Ic shift
and
.Ic let .
Arithmetic evaluation is also performed on argument operands of the built-in
command
.Ic printf
that correspond to numeric format specifiers in the format operand.
See
.Xr printf 1 .
Evaluations are performed using double precision floating point arithmetic or
long double precision floating point for systems that provide this data type.
Floating point constants follow the
.Sy ANSI-C
programming language floating point conventions.
The floating point constants
.Dv Nan
and
.Dv Inf
can be used to represent "not a number" and infinity respectively.
Integer constants follow the
.Sy ANSI-C
programming language integer constant conventions although only single byte
character constants are recognized and character casts are not recognized.
Constants can be of the form
.Oo Ar base Ns No \&# Oc Ns Ar n
where
.Ar base
is a decimal number between two and sixty-four representing the arithmetic base
and
.Ar n
is a number in that base.
The digits greater than
.Sy 9
are represented by the lower case letters, the upper case letters,
.Sy @ ,
and
.Sy _
respectively.
For bases less than or equal to
.Sy 36 ,
upper and lower case characters can be used interchangeably.
.Pp
An arithmetic expression uses the same syntax, precedence, and associativity of
expression as the C language.
All the C language operators that apply to floating point quantities can be
used.
In addition, the operator
.Sy **
can be used for exponentiation.
It has higher precedence than multiplication and is left associative.
When the value of an arithmetic variable or subexpression can be represented as
a long integer, all C language integer arithmetic operations can be performed.
Variables can be referenced by name within an arithmetic expression without
using the parameter expansion syntax.
When a variable is referenced, its value is evaluated as an arithmetic
expression.
.Pp
Any of the following math library functions that are in the C math library can
be used within an arithmetic expression:
.Pp
.Bl -inset -offset Ds -compact
.It rint round sin sinh sqrt tan tanh tgamma trunc abs
.It acos acosh asin asinh atan atan2 atanh cbrt ceil copysign
.It cos cosh erf erfc exp exp2 expm1 fabs fpclassify fdim
.It finite floor fma fmax fmin fmod hypot ilogb int isfinite
.It sinf isnan isnormal issubnormal issubordered iszero j0
.It j1 jn lgamma log log10 log2 logb nearbyint nextafter
.It nexttoward pow remainder rint round scanb signbit sin sinh
.It sqrt tan tanh tgamma trunc y0 y1 yn
.El
.Pp
In addition, arithmetic functions can be defined as shell functions with a
variant of the
.Ic function Ar name
syntax:
.Bd -ragged -offset Ds
.Sy function .sh.math\&. Ns Ar name Ar ident Sy { Ar list Sy ;}
.Ed
.Pp
where
.Ar name
is the function name used in the arithmetic expression and each identified
.Ar ident
is a name reference to the long double precision floating point argument.
The value of
.Sy .sh.value
when the function returns is the value of this function.
User defined functions can take up to 3 arguments and override C math library
functions.
.Pp
An internal representation of a
.Ar variable
as a double precision floating point can be specified with the
.Fl E Ns Op Ar n ,
.Fl F Ns Op Ar n ,
or
.Fl X Ns Op Ar n
options of the
.Ic typeset
special built-in command.
The
.Fl E
option causes the expansion of the value to be represented using scientific
notation when it is expanded.
The optional option argument
.Ar n
defines the number of significant figures.
The
.Fl F
option causes the expansion to be represented as a floating decimal number when
it is expanded.
The optional option argument
.Ar n
defines the number of places after the decimal point in this case.
The
.Fl X
option causes the expansion to be represented using the
.Sy %a
format defined by ISO C-99.
The optional option argument n defines the number of places after the decimal
(or radix) point in this case.
.Pp
An internal integer representation of a
.Ar variable
can be specified with
the
.Fl i Ns Op Ar n
option of the
.Ic typeset
special built-in command.
The optional option argument
.Ar n
specifies an arithmetic base to be used when expanding the variable.
If you do not specify an arithmetic base, base 10 is used.
.Pp
Arithmetic evaluation is performed on the value of each assignment to a
variable with the
.Fl E ,
.Fl F ,
.Fl X
or
.Fl i
option.
Assigning a floating point number to a variable whose type is an integer causes
the fractional part to be truncated.
.Ss "Prompting"
When used interactively, the shell prompts with the value of
.Ev PS1
after expanding it for parameter expansion, command substitution, and
arithmetic substitution, before reading a command.
In addition, each single
.Sy \&!
in the prompt is replaced by the command number.
A
.Sy \&!\&!
is required to place a literal
.Sy \&!
in the prompt.
If at any time a NEWLINE is typed and further input is needed to complete a
command, then the secondary prompt, that is, the value of
.Ev PS2 ,
is issued.
.Ss "Conditional Expressions"
A
.Sy conditional expression
is used with the
.Sy [[
compound command to test attributes of files and to compare strings.
Field splitting and file name generation are not performed on the words between
.Sy [[
and
.Sy ]] .
.Pp
Each expression can be constructed from one or more of the following unary or
binary expressions:
.Bl -tag -width Ar
.It Fl a Ar file
True, if
.Ar file
exists.
.Pp
This option is the same as
.Fl e .
This option is obsolete.
.It Fl b Ar file
True, if
.Ar file
exists and is a block special file.
.It Fl c Ar file
True, if
.Ar file
exists and is a character special file.
.It Fl d Ar file
True, if
.Ar file
exists and is a directory.
.It Fl e Ar file
True, if
.Ar file
exists.
.It Fl f Ar file
True, if
.Ar file
exists and is an ordinary file.
.It Fl g Ar file
True, if
.Ar file
exists and it has its
.Sy setgid
bit set.
.It Fl G Ar file
True, if
.Ar file
exists and its group matches the effective group id of this process.
.It Fl h Ar file
True, if
.Ar file
exists and is a symbolic link.
.It Fl k Ar file
True, if
.Ar file
exists and it has its sticky bit set.
.It Fl L Ar file
True, if
.Ar file
exists and is a symbolic link.
.It Fl n Ar string
True, if length of
.Ar string
is
.Sy non-zero .
.It Fl N Ar file
True, if
.Ar file
exists and the modification time is greater than the last
access time.
.It Fl o Ar option
True, if option named
.Ar option
is on.
.It Fl o Sy \&? Ns Ar option
True, if option named
.Ar option
is a valid option name.
.It Fl O Ar file
True, if
.Ar file
exists and is owned by the effective user id of this process.
.It Fl p Ar file
True, if
.Ar file
exists and is a
.Sy FIFO
special file or a pipe.
.It Fl r Ar file
True, if
.Ar file
exists and is readable by current process.
.It Fl R Ar name
True if variable
.Ar name
is a name reference.
.It Fl s Ar file
True, if
.Ar file
exists and has size greater than zero.
.It Fl S Ar file
True, if
.Ar file
exists and is a socket.
.It Fl t Ar fildes
True, if file descriptor number
.Ar fildes
is open and associated with a terminal device.
.It Fl u Ar file
True, if
.Ar file
exists and it has its
.Sy setuid
bit set.
.It Fl v Ar name
True, if variable
.Ar name
is a valid variable name and is set.
.It Fl w Ar file
True, if
.Ar file
exists and is writable by current process.
.It Fl x Ar file
True, if
.Ar file
exists and is executable by current process.
If
.Ar file
exists and is a directory, then true if the current process has permission to
search in the directory.
.It Fl z Ar string
True, if length of
.Ar string
is zero.
.It Ar file1 Fl ef Ar file2
True, if
.Ar file1
and
.Ar file2
exist and refer to the same file.
.It Ar file1 Fl nt Ar file2
True, if
.Ar file1
exists and
.Ar file2
does not, or
.Ar file1
is newer
than
.Ar file2 .
.It Ar file1 Fl ot Ar file2
True, if
.Ar file2
exists and
.Ar file1
does not, or
.Ar file1
is older
than
.Ar file2 .
.It Ar string
True, if
.Ar string
is not null.
.It Ar string Sy == Ar pattern
True, if
.Ar string
matches
.Ar pattern .
Any part of
.Ar pattern
can be quoted to cause it to be matched as a string.
With a successful match to
.Ar pattern , the
.Ev \&.sh.match
array variable contains the match and sub-pattern matches.
.It Ar string Sy = Ar pattern
Same as
.Sy == ,
but is obsolete.
.It Ar string Sy != Ar pattern
True, if
.Ar string
does not match
.Ar pattern .
When the
.Ar string
matches the
.Ar pattern
the
.Ev \&.sh.match
array variable contains the match and sub-pattern matches.
.It Ar string Sy =~ Ar ere
True if
.Ar string
matches the pattern
.Sy ~(E) Ns Ar ere
where
.Ar ere
is an extended regular expression.
.It Ar string1 Sy \&< Ar string2
True, if
.Ar string1
comes before
.Ar string2
based on
.Sy ASCII
value of their characters.
.It Ar string1 Sy \&> Ar string2
True, if
.Ar string1
comes after
.Ar string2
based on
.Sy ASCII
value of
their characters.
.El
.Pp
In each of the above expressions, if
.Ar file
is of the form
.Pa /dev/fd/ Ns Ar n ,
where
.Ar n
is an integer, the test is applied to the open file whose descriptor number is
.Ar n .
.Pp
The following obsolete arithmetic comparisons are also supported:
.Bl -tag -width 18n
.It Ar exp1 Fl eq Ar exp2
True, if
.Ar exp1
is equal to
.Ar exp2 .
.It Ar exp1 Fl ge Ar exp2
True, if
.Ar exp1
is greater than or equal to
.Ar exp2 .
.It Ar exp1 Fl gt Ar exp2
True, if
.Ar exp1
is greater than
.Ar exp2 .
.It Ar exp1 Fl le Ar exp2
True, if
.Ar exp1
is less than or equal to
.Ar exp2 .
.It Ar exp1 Fl lt Ar exp2
True, if
.Ar exp1
is less than
.Ar exp2 .
.It Ar exp1 Fl ne Ar exp2
True, if
.Ar exp1
is not equal to
.Ar exp2 .
.El
.Pp
A compound expression can be constructed from these primitives by using any of
the following, listed in decreasing order of precedence:
.Bl -tag -width Ds
.It Sy \&( Ns Ar expression Ns Sy \&)
True, if
.Ar expression
is true.
Used to group expressions.
.It Sy \&! Ar expression
True, if
.Ar expression
is false.
.It Ar expression1 Sy \&&& Ar expression2
True, if
.Ar expression1
and
.Ar expression2
are both true.
.It Ar expression1 Sy \&|\&| Ar expression2
True, if either
.Ar expression1
or
.Ar expression2
is true.
.El
.Ss "Input and Output"
Before a command is executed, its input and output can be redirected using a
special notation interpreted by the shell.
The following can appear anywhere in
a simple command or can precede or follow a command and are
.Em not
passed on to the invoked command.
Command substitution, parameter expansion, and arithmetic substitution occur
before
.Ar word
or
.Ar digit
is used except as noted in this section.
File name generation occurs only if the shell is interactive and the pattern
matches a single file.
Field splitting is not performed.
.Pp
In each of the following redirections, if
.Ar file
is of the form
.Pa /dev/sctp/ Ar host Ns Sy / Ns Ar port ,
.Pa /dev/tcp/ Ar host Ns Sy / Ns Ar port ,
or
.Pa /dev/udp/ Ar host Ns Sy / Ns Ar port ,
where
.Ar host
is a hostname or host address, and
.Ar port
is a service specified by name or an integer port number, then the redirection
attempts to make a
.Sy tcp ,
.Sy sctp
or
.Sy udp
connection to the corresponding socket.
.Pp
No intervening space is allowed between the characters of redirection
operators.
.Bl -tag -width Ar
.It Sy \&< Ns Ar word
Use file
.Ar word
as standard input (file descriptor 0).
.It Sy \&> Ns Ar word
Use file
.Ar word
as standard output (file descriptor 1).
If the file does not exist then it is created.
If the file exists, and the
.Sy noclobber
option is on, this causes an error, otherwise, it is truncated to zero length.
.It Sy \&>\&| Ns Ar word
Same as
.Sy > ,
except that it overrides the
.Sy noclobber
option.
.It Sy \&>\&; Ns Ar word
Write output to a temporary file.
If the command completes successfully rename it to word, otherwise, delete the
temporary file.
>;word cannot be used with the
.Xr exec 2
built-in.
.It Sy \&>> Ns Ar word
Use file
.Ar word
as standard output.
If the file exists, then output is appended to it (by first seeking to the
end-of-file), otherwise, the file is created.
.It Sy \&<> Ns Ar word
Open file
.Ar word
for reading and writing as standard input.
.It Sy \&<< Ns Oo Fl Oc Ns Ar word
The shell input is read up to a line that is the same as
.Ar word
after any quoting has been removed, or to an end-of-file.
No parameter substitution, command substitution, arithmetic substitution or
file name generation is performed on
.Ar word .
The resulting document, called a
.Sy here-document ,
becomes the standard input.
If any character of
.Ar word
is quoted, then no interpretation is placed upon the characters of the
document.
Otherwise, parameter expansion, command substitution, and arithmetic
substitution occur,
\eNEWLINE is ignored, and \e must be used to quote the characters
.Sy \e ,
.Sy $
and
.Sy \&` .
If
.Sy -
is appended to
.Sy << ,
then all
leading tabs are stripped from
.Ar word
and from the document.
If
.Sy #
is
appended to
.Sy << ,
then leading SPACEs and TABs are stripped off the first line of the document
and up to an equivalent indentation is stripped from the remaining lines and
from
.Ar word .
A tab stop is assumed to occur at every 8 columns for the purposes of
determining the indentation.
.It Sy \&<<< Ns Ar word
A short form of here document in which
.Ar word
becomes the contents of the here-document after any parameter expansion,
command substitution, and arithmetic substitution occur.
.It Sy \&<& Ns Ar digit
The standard input is duplicated from file descriptor
.Ar digit ,
and similarly for the standard output using
.Sy >&
.Ar digit .
See
.Xr dup 2 .
.It Sy \&<& Ns Ar digit Ns Sy -
The file descriptor specified by
.Ar digit
is moved to standard input.
Similarly for the standard output using
.Sy >& Ns Ar digit Ns Sy - .
.It Sy <&-
The standard input is closed.
Similarly for the standard output using
.Sy >&- .
.It Sy <&p
The input from the co-process is moved to standard input.
.It Sy >&p
The output to the co-process is moved to standard output.
.It Sy <#(( Ns Ar expr Ns Sy ))
Evaluate arithmetic expression
.Ar expr
and position file descriptor 0 to the resulting value bytes from the start of
the file.
The variables
.Ev CUR
and
.Ev EOF
evaluate to the current offset and end-of-file offset respectively when
evaluating
.Ar expr .
.It Sy >#(( Ns Ar expr Ns Sy ))
The same as
.Sy <#
except applies to file descriptor 1.
.It Sy <# Ns Ar pattern
Seek forward to the beginning of the next line containing pattern.
.It Sy <## Ns Ar pattern
The same as
.Sy <# ,
except that the portion of the file that is skipped is copied to standard
output.
.El
.Pp
If one of the redirection operators is preceded by a digit, with no intervening
space, then the file descriptor number referred to is that specified by the
digit (instead of the default 0 or 1).
If one of the redirection operators
other than
.Sy >&-
and the
.Sy >#
and
.Sy <#
forms, is preceded by
.Sy \&{ Ns Ar varname Ns Sy \&}
with no intervening space, then a file descriptor
number
.Sy > 10
is selected by the shell and stored in the variable
.Ar varname .
If
.Sy >&-
or the any of the
.Sy >#
and
.Sy <#
forms is preceded by
.Sy \&{ Ns Ar varname Ns Sy \&}
the value of
.Ar varname
defines the file descriptor to close or position.
For example:
.Pp
.Dl ... 2>&1
.Pp
means file descriptor 2 is to be opened for writing as a duplicate of file
descriptor 1 and
.Pp
.Dl exec [n]<file
.Pp
means open
.Ar file
for reading and store the file descriptor number in variable
.Ar n .
The order in which redirections are specified is significant.
The shell evaluates each redirection in terms of the
.Pq Ar file_descriptor , Ar file
association at the time of evaluation.
For example:
.Pp
.Dl ... 1>fname 2>&1
.Pp
first associates file descriptor 1 with file
.Ar fname .
It then associates file descriptor 2 with the file associated with file
descriptor 1, that is,
.Ar fname .
If the order of redirections were reversed, file descriptor 2 would be
associated with the terminal (assuming file descriptor 1 had been) and then
file descriptor 1 would be associated with file
.Ar fname .
If a command is followed by
.Sy \&&
and job control is not active, the default standard input for the command is
the empty file
.Pa /dev/null .
Otherwise, the environment for the execution of a command contains the file
descriptors of the invoking shell as modified by input and output
specifications.
.Ss "Environment"
The
.Sy environment
is a list of name-value pairs that is passed to an executed program in the same
way as a normal argument list.
See
.Xr environ 5 .
.Pp
The names must be
.Ar identifiers
and the values are character strings.
The shell interacts with the environment in several ways.
On invocation, the shell scans the environment and creates a variable for each
name found, giving it the corresponding value and attributes and marking it
.Ic export .
Executed commands inherit the environment.
If the user modifies the values of these variables or creates new ones, using
the
.Ic export
or
.Ic typeset Fl x
commands, they become part of the environment.
The environment seen by any executed command is thus composed of any name-value
pairs originally inherited by the shell, whose values can be modified by the
current shell, plus any additions which must be noted in
.Ic export
or
.Ic typeset Fl x
commands.
The environment for any simple-command or function can be augmented by
prefixing it with one or more variable assignments.
A variable assignment argument is a word of the form
.Ar identifier Ns Sy = Ns Ar value .
Thus:
.Pp
.Dl TERM=450 cmd args
.Pp
and
.Pp
.Dl (export TERM; TERM=450; cmd args)
.Pp
are equivalent
.Pq as far as the execution of Ar cmd No is concerned
except for special built-in commands listed in the
.Sx Built-Ins
section, those that are preceded with a dagger.
If the obsolete
.Fl k
option is set, all variable assignment arguments are placed in the environment,
even if they occur after the command name.
.Pp
The following example first prints
.Sy a=b c
and then
.Sy c :
.Bd -literal -offset indent
echo a=b c
set -k
echo a=b c
.Ed
.Pp
This feature is intended for use with scripts written for early versions of the
shell and its use in new scripts is strongly discouraged.
.Ss "Functions"
For historical reasons, there are two ways to define functions, the
.Ar name Ns Sy ()
syntax and the
.Ic function Ar name
syntax.
These are
described in the
.Sx Commands
section of this manual page.
.Pp
Shell functions are read in and stored internally.
Alias names are resolved when the function is read.
Functions are executed like commands with the arguments passed as positional
parameters.
See the
.Sx Execution
section of this manual page for details.
.Pp
Functions defined by the
.Ic function Ar name
syntax and called by name execute in the same process as the caller and share
all files and present working directory with the caller.
Traps caught by the caller are reset to their default action inside the
function.
A trap condition that is not caught or ignored by the function causes the
function to terminate and the condition to be passed on to the caller.
A trap on
.Sy EXIT
set inside a function is executed in the environment of the caller after the
function completes.
Ordinarily, variables are shared between the calling program and the function.
However, the
.Ic typeset
special built-in command used within a function defines local variables whose
scope includes the current function.
They can be passed to functions that they call in the variable assignment list
that precedes the call or as arguments passed as name references.
Errors within functions return control to the caller.
.Pp
Functions defined with the
.Ar name Ns Sy ()
syntax and functions defined with the
.Ic function Ar name
syntax that are invoked with the
.Ic \&.
special built-in are executed in the caller's environment and share all
variables and traps with the caller.
Errors within these function executions cause the script that contains them to
abort.
.Pp
The special built-in command
.Ic return
is used to return from function calls.
.Pp
Function names can be listed with the
.Fl f
or
.Sy +f
option of the
.Ic typeset
special built-in command.
The text of functions, when available, is also listed with
.Fl f .
Functions can be undefined with the
.Fl f
option of the
.Ic unset
special built-in command.
.Pp
Ordinarily, functions are unset when the shell executes a shell script.
Functions that need to be defined across separate invocations of the shell
should be placed in a directory and the
.Ev FPATH
variable should contain the
name of this directory.
They can also be specified in the
.Ev ENV
file.
.Ss "Discipline Functions"
Each variable can have zero or more discipline functions associated with it.
The shell initially understands the discipline names
.Ic get ,
.Ic set ,
.Ic append ,
and
.Ic unset
but on most systems others can be added at run time via the C programming
interface extension provided by the
.Ic builtin
built-in utility.
If the
.Ic get
discipline is defined for a variable, it is invoked whenever the specified
variable is referenced.
If the variable
.Sy \&.sh.value
is assigned a value inside the discipline function, the referenced variable is
evaluated to this value instead.
If the
.Ic set
discipline is defined for a variable, it is invoked whenever the specified
variable is assigned a value.
If the
.Ic append
discipline is defined for a variable, it is invoked whenever a value is
appended to the specified variable.
The variable
.Sy \&.sh.value
is specified the value of the variable before invoking the discipline, and the
variable is assigned the value of
.Sy \&.sh.value
after the discipline completes.
If
.Sy .sh.value
is
.Ic unset
inside the discipline, then that value is unchanged.
If the
.Ic unset
discipline is defined for a variable, it is invoked whenever the specified
variable is unset.
The variable is not unset unless it is unset explicitly from within this
discipline function.
.Pp
The variable
.Sy \&.sh.name
contains the name of the variable for which the discipline function is called,
.Sy \&.sh.subscript
is the subscript of the variable, and
.Sy \&.sh.value
contains the value being assigned inside the
.Ic set
discipline function.
For the
.Sy set
discipline, changing
.Sy \&.sh.value
changes the value that gets assigned.
The variable
.Sy _
is a reference to the variable including the subscript if any.
For the
.Ic set
discipline, changing
.Sy \&.sh.value
will change the value that gets assigned.
Finally, the expansion
.Sy ${ Ns Ar var.name Ns Sy } ,
when name is the name of a discipline, and there is no variable of this name,
is equivalent to the command substitution
.Sy ${ Ns Ar var.name Ns Sy ;} .
.Ss "Name Spaces"
Commands and functions that are executed as part of the
.Ar list
of a
.Ic namespace
command that modify variables or create new ones, create a new variable whose
name is the name of the name space as given by
.Ar identifier
preceded by two dots
.Pq Sy \&.. .
When a variable whose name is
.Ar name
is referenced, it is first searched for using
.Sy \&. Ns Ar identifier Ns Sy \&. Ns Ar name Ns Sy \&.
Similarly, a function defined by a command in the
.Ic namespace Ar list
is created using the name space name preceded by two dots
.Pq Sy \&.. .
.Pp
When  the
.Ar list
of a
.Ic namespace
command contains a
.Ic namespace
command, the names of variables and functions that are created consist
of the variable or function name preceded by the list of
.Ar identifier Ns No s ,
each preceded by two dots
.Pq Sy \&.. .
.Pp
Outside of a name space, a variable or function created inside a name space can
be referenced by preceding it with the name space name.
.Pp
By default, variables staring with
.Sy \&.sh
are in the
.Sy sh
name space.
.Ss "Typed Variables"
Typed variables provide a way to create data structure and objects.
A type can be defined either by a shared library, by the
.Ic enum
built-in command described below, or by using the
.Fl T
option of the
.Ic typeset
built-in command.
With the
.Fl T
option of
.Ic typeset ,
the type name, specified as an option argument to
.Fl T ,
is set with a compound variable assignment that defines the type.
Function definitions can appear inside the compound variable assignment and
these become discipline functions for this type and can be invoked or redefined
by each instance of the type.
The function name
.Sy create
is treated specially.
It is invoked for each instance of the type that is created but is not
inherited and cannot be redefined for each instance.
.Pp
When a type is defined a special built-in command of that name is added.
These built-ins are declaration commands and follow the same expansion rules as
all the special built-in commands defined below that are preceded by a dot
.Pq Sy \&. .
These commands can subsequently be used inside further type definitions.
The man page for these commands can be generated by using the
.Fl -man
option or any of the other
.Fl -
options described with
.Ic getopts .
The
.Fl r ,
.Fl a ,
.Fl A ,
.Fl h
and
.Fl S
options of
.Ic typeset
are permitted with each of these new built-ins.
.Pp
An instance of a type is created by invoking the type name followed by one or
more instance names.
Each instance of the type is initialized with a copy of the sub-variables
except for sub-variables that are defined with the
.Fl s
option.
Variables defined with
.Fl S
are shared by all instances of the type.
Each instance can change the value of any sub-variable and can also define new
discipline functions of the same names as those defined by the type definition
as well as any standard discipline names.
No additional sub-variables can be defined for any instance.
.Pp
When defining a type, if the value of a sub-variable is not set and the
.Fl r
attribute is specified, it causes the sub-variable to be a required
sub-variable.
Whenever an instance of a type is created, all required sub-variables must be
specified.
These sub-variables become readonly in each instance.
.Pp
When
.Ic unset
is invoked on a sub-variable within a type, and the
.Fl r
attribute has not been specified for this field, the value is reset to the
default value associative with the type.
Invoking
.Ic unset
on a type instance not contained within another type deletes all sub-variables
and the variable itself.
A type definition can be derived from another type definition by defining the
first sub-variable name as
.Sy _
and defining its type as the base type.
Any remaining definitions will be additions and modifications that apply to the
new type.
If the new type name is the same is that of the base type, the type will be
replaced and the original type will no longer be accessible.
.Pp
The
.Ic typeset
command with
.Fl T
and no option argument or operands will write all the type definitions to
standard output in a form that that can be read in to create all the types.
.Ss "Jobs"
If the monitor option of the
.Ic set
command is turned on, an interactive shell associates a job with each pipeline.
It keeps a table of current jobs, printed by the
.Ic jobs
command, and assigns them small integer numbers.
When a job is started asynchronously with
.Sy \&& ,
the shell prints a line which looks like:
.Pp
.Dl [1] 1234
.Pp
indicating that the job which was started asynchronously was job number 1 and
had one (top-level) process, whose process id was
.Sy 1234 .
.Pp
If you are running a job and wish to stop it, CTRL-z sends a
.Sy STOP
signal to the current job.
The shell normally displays a message that the job has been stopped, and
displays another prompt.
You can then manipulate the state of this job, putting it in the background
with the
.Ic bg
command, or run some other commands and then eventually bring the job back into
the foreground with the foreground command
.Ic fg .
A CTRL-z takes effect immediately and is like an interrupt in that pending
output and unread input are discarded when it is typed.
.Pp
A job being run in the background stops if it tries to read from the terminal.
Background jobs are normally allowed to produce output, but this can be
disabled by giving the command
.Sy stty tostop .
If you set this
.Sy tty
option, then background jobs stop when they try to produce output like they do
when they try to read input.
.Pp
A job pool is a collection of jobs started with
.Ar list Sy &
associated with a name.
.Pp
There are several ways to refer to jobs in the shell.
A job can be referred to
by the process id of any process of the job or by one of the following:
.Bl -tag -width Ar
.It Sy % Ns Ar number
The job with the specified number.
.It Ar pool
All the jobs in the job pool named by
.Ar pool .
.It Ar pool Ns Sy \&. Ns Ar number
The job number
.Ar number
in the pool named by
.Ar pool .
.It Sy % Ns Ar string
Any job whose command line begins with
.Ar string .
.It Sy %? Ns Ar string
Any job whose command line contains
.Ar string .
.It Sy %%
Current job.
.It Sy %+
Equivalent to
.Sy %% .
.It Sy %-
Previous job.
.El
.Pp
In addition, unless noted otherwise, wherever a job can be specified, the name
of a background job pool can be used to represent all the jobs in that pool.
.Pp
The shell learns immediately whenever a process changes state.
It normally informs you whenever a job becomes blocked so that no further
progress is possible, but only just before it prints a prompt.
This is done so that it does not otherwise disturb your work.
The notify option of the
.Ic set
command causes the shell to print these job change messages as soon as they
occur.
.Pp
When the
.Sy monitor
option is on, each background job that completes triggers any trap set for
.Dv CHLD .
.Pp
When you try to leave the shell while jobs are running or stopped, you are
warned that
.Pp
.D1 You have stopped(running) jobs.
.Pp
You can use the
.Ic jobs
command to see what they are.
If you immediately try to exit again, the shell does not warn you a second
time, and the stopped jobs are terminated.
When a login shell receives a
.Sy HUP
signal, it sends a
.Sy HUP
signal to each job that has not been disowned with the
.Ic disown
built-in command.
.Ss "Signals"
The
.Sy INT
and
.Sy QUIT
signals for an invoked command are ignored if the command is followed by
.Sy \&&
and the
.Sy monitor
option is not active.
Otherwise, signals have the values inherited by the shell from its parent.
See the
.Ic trap
built-in command.
.Ss "Execution"
Each time a command is read, the substitutions are carried out.
If the command name matches one of the ones in the
.Sx Special Built-in Commands
section of this manual page, it is executed within the current shell process.
Next, the command name is checked to see if it matches a user defined function.
If it does, the positional parameters are saved and then reset to the arguments
of the function call.
A function is also executed in the current shell process.
When the function completes or issues a return, the positional parameter list
is restored.
For functions defined with the
.Ic function Ar name
syntax, any trap set on
.Dv EXIT
within the function is executed.
The exit value of a function is the value of the last command executed.
If a command name is not a special built-in command or a user defined function,
but it is one of the built-in commands, it is executed in the current shell
process.
.Pp
The shell variables
.Ev PATH
and
.Ev FPATH
define the search path for the directory containing the command.
Alternative directory names are separated by a colon
.Pq Sy \&: .
The default path is
.Pa /bin Ns Sy \&: Ns Pa /usr/bin Ns Sy \&: ,
specifying
.Pa /bin ,
.Pa /usr/bin ,
and the current directory in that order.
The current directory can be specified by two or more adjacent colons, or by a
colon at the beginning or end of the path list.
If the command name contains a slash
.Pq Sy \&/ ,
the search path is not used.
Otherwise, each directory in the list of directories defined by
.Ev PATH
and
.Ev FPATH
is checked in order.
If the directory being searched is contained in the value of the
.Ev FPATH
variable and contains a file whose name matches the command being searched,
then this file is loaded into the current shell environment as if it were the
argument to the
.Ic \&.
command except that only preset aliases are expanded, and a function of the
specified name is executed as described in this manual page.
.Pp
If this directory is not in
.Ev FPATH ,
the shell first determines whether there is a built-in version of a command
corresponding to a given pathname and, if so, it is invoked in the current
process.
If no built-in is found, the shell checks for a file named
.Pa \&.paths
in this directory.
If found and there is a line of the form:
.Pp
.D1 Ev FPATH Ns = Ns Ar path
.Pp
where
.Ar path
is an existing directory, then that directory is searched immediately after the
current directory as if it were found in the
.Ev FPATH
variable.
If
.Ar path
does not begin with
.Sy / ,
it is checked for relative to the directory being searched.
.Pp
The
.Pa \&.paths
file is then checked for a line of the form:
.Pp
.D1 Ev PLUGIN_LIB Ns = Ns Ar libname Ns Oo Sy \&: Ns Ar libname Oc Ns No ...
.Pp
Each library named by
.Ar libname
will be searched for as if it were an option argument to
.Ic builtin Fl f
and, if it contains a built-in of the specified name, this is executed instead
of a command by this name.
.Pp
Any built-in loaded from a library found this way will be associated with the
directory containing the
.Pa \&.paths
file so it will only execute if not found in an earlier directory.
.Pp
Finally, the directory will be checked for a file of the given name.
If the file has execute permission but is not an
.Pa a.out
file, it is assumed to be a file containing shell commands.
A separate shell is spawned to read it.
All non-exported variables are removed in this case.
If the shell command file doesn't have read permission, and/or if the
.Sy setuid
and
.Sy setgid
bits are set on the file, then the shell executes an agent whose job it is to
set up the permissions and execute the shell with the shell command file passed
down as an open file.
If the
.Pa \&.paths
contains a line of the form:
.Pp
.D1 Sy name= Ns Ar value
.Pp
in the
first or second line, then the environment variable
.Ar name
is modified by prepending the directory specified by
.Ar value
to the directory list.
If
.Ar value
is not an absolute directory, then it specifies a directory relative to the
directory in which the executable was found.
If the environment variable
.Ev name
does not already exist it will be added to the environment list for the
specified command.
A parenthesized command is executed in a sub-shell without removing
non-exported variables.
.Ss "Command Re-entry"
The text of the last
.Ev HISTSIZE
.Pq default 512
commands entered from a terminal device is saved in a history file.
The file
.Pa $HOME/.sh_history
is used if the
.Ev HISTFILE
variable is not set or if the file it names is not writable.
A shell can access the commands of all interactive shells which use the same
named
.Ev HISTFILE .
The built-in command
.Ic hist
is used to list or edit a portion of this file.
The portion of the file to be edited or listed can be selected by number or by
giving the first character or characters of the command.
A single command or range of commands can be specified.
If you do not specify an editor program as an argument to
.Ic hist
then the value of the variable
.Ev HISTEDIT
is used.
If
.Ev HISTEDIT
is unset, the obsolete variable
.Ev FCEDIT
is used.
If
.Ev FCEDIT
is not defined, then
.Pa /bin/ed
is used.
The edited commands are printed and executed again upon leaving the editor
unless you quit without writing.
The
.Fl s
option
.Pq and in obsolete versions, the editor name Sy \&-
is used to skip the editing phase and to re-execute the command.
In this case a substitution parameter of the form
.Ar old Ns Sy = Ns Ar new
can be used to modify the command before execution.
For example, with the preset alias
.Ic r ,
which is aliased to
.Ic hist -s ,
typing
.Sq r bad=good c
re-executes the most recent
command which starts with the letter
.Sy c ,
replacing the first occurrence of the string
.Sq bad
with the string
.Sq good .
.Ss "Inline Editing Options"
Normally, each command line entered from a terminal device is simply typed
followed by a NEWLINE (RETURN or LINE FEED).
If either the
.Sy emacs ,
.Sy gmacs ,
or
.Sy vi
option is active, the user can edit the command line.
To be in either of these edit modes set the corresponding option.
An editing option is automatically selected each time the
.Ev VISUAL
or
.Ev EDITOR
variable is assigned a value ending in either of these option names.
.Pp
The editing features require that the user's terminal accept RETURN as carriage
return without line feed and that a SPACE must overwrite the current character
on the screen.
.Pp
Unless the
.Sy multiline
option is on, the editing modes implement a concept where the user is looking
through a window at the current line.
The window width is the value of
.Ev COLUMNS
if it is defined, otherwise
.Sy 80 .
If the window width is too small to display the prompt and leave at least 8
columns to enter input, the prompt is truncated from the left.
If the line is longer than the window width minus two, a mark is displayed at
the end of the window to notify the user.
As the cursor moves and reaches the window boundaries the window is centered
about the cursor.
The mark is a
.Sy >
.Pq Sy \&< Ns \&, Sy \&*
if the line extends on the right, left, or both sides of the window.
.Pp
The search commands in each edit mode provide access to the history file.
Only strings are matched, not patterns, although a leading
.Sy ^
in the string restricts the match to begin at the first character in the line.
.Pp
Each of the edit modes has an operation to list the files or commands that
match a partially entered word.
When applied to the first word on the line, or the first word after a
.Sy \&; ,
.Sy \&| ,
.Sy \&& ,
or
.Sy \&( ,
and the word does not begin with
.Sy \&~
or contain a
.Sy \&/ ,
the list of aliases, functions, and executable commands defined by the
.Ev PATH
variable that could match the partial word is displayed.
Otherwise, the list of files that match the specified word is displayed.
If the partially entered word does not contain any file expansion characters, a
.Sy *
is appended before generating these lists.
After displaying the generated list, the input line is redrawn.
These operations are called command name listing and file name listing,
respectively.
There are additional operations, referred to as command name completion and
file name completion, which compute the list of matching commands or files, but
instead of printing the list, replace the current word with a complete or
partial match.
For file name completion, if the match is unique, a
.Sy /
is appended if the file is a directory and a space is appended if the file is
not a directory.
Otherwise, the longest common prefix for all the matching files replaces the
word.
For command name completion, only the portion of the file names after the last
.Sy /
are used to find the longest command prefix.
If only a single name matches this prefix, then the word is replaced with the
command name followed by a space.
When using a
.Dv TAB
for completion that does not yield a unique match, a subsequent
.Dv TAB
provides a numbered list of matching alternatives.
A specific selection can be made by entering the selection number followed by a
.Dv TAB .
.Ss "Key Bindings"
The
.Sy KEYBD
trap can be used to intercept keys as they are typed and change the characters
that are actually seen by the shell.
This trap is executed after each character (or sequence of characters when the
first character is ESC) is entered while reading from a terminal.
.Pp
The variable
.Sy \&.sh.edchar
contains the character or character sequence which generated the trap.
Changing the value of
.Sy \&.sh.edchar
in the trap action causes the shell to behave as if the new value were entered
from the keyboard rather than the original value.
The variable
.Sy \&.sh.edcol
is set to the input column number of the cursor at the time of the input.
The variable
.Sy \&.sh.edmode
is set to
.Sy ESC
when in
.Sy vi
insert mode and is null otherwise.
By prepending
.Sy ${.sh.editmode}
to a value assigned to
.Sy \&.sh.edchar
it causes the shell to change to control mode if it is not already in this
mode.
.Pp
This trap is not invoked for characters entered as arguments to editing
directives, or while reading input for a character search.
.Ss "emacs Editing Mode"
This mode is entered by enabling either the
.Sy emacs
or
.Sy gmacs
option.
The only difference between these two modes is the way they handle
.Sy ^T .
To edit, the user moves the cursor to the point needing correction and then
inserts or deletes characters or words as needed.
All the editing commands are control characters or escape sequences.
.Pp
The notation for control characters is caret
.Pq Sy ^
followed by the character.
.Pp
For example,
.Sy ^F
is the notation for CTRL/F.
This is entered by depressing
.Sy f
while holding down the CTRL (control) key.
The SHIFT key is not depressed.
(The notation
.Sy ^?
indicates the DEL (delete) key).
.Pp
The notation for escape sequences is
.Sy M-
followed by a character.
For example,
.Sy M-f
.Pq pronounced Sy Meta f
is entered by depressing ESC
.Pq Sy ASCII 033
followed by
.Ql f .
.Sy M-F
is the notation for ESC followed by
.Ql F .
.Pp
All edit commands operate from any place on the line, not just at the
beginning.
The RETURN or the LINE FEED key is not entered after edit commands except when
noted.
.Bl -tag -width Ar
.It Sy ^F
Move the cursor forward (right) one character.
.It Sy M-[C
Move the cursor forward (right) one character.
.It Sy M-f
Move the cursor forward one word.
The
.Sy emacs
editor's idea of a word is a string of characters consisting of only letters,
digits and underscores.
.It Sy ^B
Move the cursor backward (left) one character.
.It Sy M-[D
Move the cursor backward (left) one character.
.It Sy M-b
Move the cursor backward one word.
.It Sy ^A
Move the cursor to the beginning of the line.
.It Sy M-[H
Move the cursor to the beginning of the line.
.It Sy ^E
Move the cursor to the end of the line.
.It Sy M-[Y
Move the cursor to the end of line.
.It Sy ^] Ns Ar char
Move the cursor forward to the character
.Ar char
on the current line.
.It Sy M-^\&] Ns Ar char
Move the cursor backwards to the character
.Ar char
on the current line.
.It Sy ^X^X
Interchange the cursor and the mark.
.It Ar erase
Delete the previous character.
The user-defined erase character is defined by the
.Xr stty 1
command, and is usually
.Sy ^H
or
.Sy # .
.It Ar lnext
Removes the next character's editing features.
The user-defined literal next character is defined by the
.Xr stty 1
command, or is
.Sy ^V
if not defined.
.It Sy ^D
Delete the current character.
.It Sy M-d
Delete the current word.
.It Sy M-^H
MetaBACKSPACE.
Delete the previous word.
.It Sy M-h
Delete the previous word.
.It Sy M-^\&?
MetaDEL.
Delete the previous word.
If your interrupt character is
.Sy ^?
(DEL, the default), this command does not work.
.It Sy ^T
Transpose the current character with the previous character, and advance the
cursor in
.Sy emacs
mode.
Transpose two previous characters in
.Sy gmacs
mode.
.It Sy ^C
Capitalize the current character.
.It Sy M-c
Capitalize the current word.
.It Sy M-l
Change the current word to lower case.
.It Sy ^K
Delete from the cursor to the end of the line.
If preceded by a numerical parameter whose value is less than the current
cursor position, delete from specified position up to the cursor.
If preceded by a numerical parameter whose value is greater than the current
cursor position, then delete from cursor up to specified cursor position.
.It Sy ^W
Kill from the cursor to the mark.
.It Sy M-p
Push the region from the cursor to the mark on the stack.
.It Ar kill
Kill the entire current line.
The user-defined kill character is defined by the
.Xr stty 1
command, usually a
.Sy ^G
or
.Sy @ .
If two kill characters are entered in succession, all kill characters from then
on cause a line feed.
This is useful when using paper terminals.
.It Sy ^Y
Restore the last item removed from line.
Yank the item back to the line.
.It Sy ^L
Line feed and print the current line.
.It Sy M-^L
Clear the screen.
.It Sy ^@
Null character.
Set mark.
.It Sy M- Ns Ar space
MetaSPACE.
Set the mark.
.It Sy ^J
New line.
Execute the current line.
.It Sy ^M
Return.
Execute the current line.
.It Sy EOF
End-of-file character, normally
.Sy ^D ,
is processed as an
.Sy end-of-file
only if the current line is null.
.It Sy ^P
Fetch the previous command.
Each time
.Sy ^P
is entered the previous command back in time is accessed.
Moves back one line when it is not on the first line of a multi-line command.
.It Sy M-[A
.ad
Equivalent to
.Sy ^P .
.It Sy M-<
Fetch the least recent (oldest) history line.
.It Sy M->
Fetch the most recent (youngest) history line.
.It Sy ^N
Fetch the next command line.
Each time
.Sy ^N
is entered the next command line forward in time is accessed.
.It Sy M-[B
Equivalent to
.Sy ^N .
.It Sy ^R Ns Ar string
Reverse search history for a previous command line containing
.Ar string .
If a parameter of zero is specified, the search is forward.
.Ar string
is terminated by a RETURN or NEWLINE.
If string is preceded by a
.Sy ^ ,
the matched line must begin with
.Ar string .
If
.Ar string
is omitted, then the next command line containing the most recent
.Ar string
is accessed.
In this case a parameter of zero reverses the direction of the search.
.It Sy ^O
Operate.
Execute the current line and fetch the next line relative to current line from
the history file.
.It Sy M- Ns Ar digits
Escape.
Define numeric parameter.
The digits are taken as a parameter to the next command.
The commands that accept a parameter are:
.Sy ^F ,
.Sy ^B ,
.Sy ERASE ,
.Sy ^C ,
.Sy ^D ,
.Sy ^K ,
.Sy ^R ,
.Sy ^P ,
.Sy ^N ,
.Sy ^] ,
.Sy M-\&. ,
.Sy M- ,
.Sy M-^\&] ,
.Sy M-_ ,
.Sy M-= ,
.Sy M-b ,
.Sy M-c ,
.Sy M-d ,
.Sy M-f ,
.Sy M-h ,
.Sy M-l ,
and
.Sy M-^H .
.It Sy M- Ns Ar letter
Soft-key.
Search the alias list for an alias by the name
.Ar letter .
If an alias of
.Ar letter
is defined, insert its value on the input queue.
.Ar letter
must not be one of the metafunctions in this section.
.It Sy M-[ Ns Ar letter
Soft key.
Search the alias list for an alias by the name
.Ar letter .
If an alias of this name is defined, insert its value on the input queue.
This can be used to program function keys on many terminals.
.It Sy M-\&.
The last word of the previous command is inserted on the line.
If preceded by a numeric parameter, the value of this parameter determines
which word to insert rather than the last word.
.It Sy M-_
Same as
.Sy M-\&. .
.It Sy M-*
Attempt filename generation on the current word.
As asterisk is appended if the word does not match any file or contain any
special pattern characters.
.It Sy M-ESC
Command or file name completion as described in this manual page.
.It Sy ^I Pq TAB
Attempts command or file name completion as described in this manual page.
If a partial completion occurs, repeating this behaves as if
.Sy M-=
were entered.
If no match is found or entered after SPACE, a TAB is inserted.
.It Sy M-=
If not preceded by a numeric parameter, generates the list of matching commands
or file names as described in this manual page.
Otherwise, the word under the cursor is replaced by the item corresponding to
the value of the numeric parameter from the most recently generated command or
file list.
If the cursor is not on a word, the word is inserted instead.
.It Sy ^U
Multiply parameter of next command by
.Sy 4 .
.It Sy \e
Escape the next character.
Editing characters, the user's erase, kill and interrupt
.Pq normally Sy ^?
characters can be entered in a command line or in a search string if preceded
by a
.Sy \e .
The
.Sy \e
removes the next character's editing features, if any.
.It Sy M-^V
Display the version of the shell.
.It Sy M-#
If the line does not begin with a
.Sy # ,
a
.Sy #
is inserted at the beginning of the line and after each NEWLINE, and the line
is entered.
This causes a comment to be inserted in the history file.
If the line begins with a
.Sy # ,
the
.Sy #
is deleted and one
.Sy #
after each NEWLINE is also deleted.
.El
.Ss vi Editing Mode
There are two typing modes.
Initially, when you enter a command you are in the input mode.
To edit, the user enters control mode by typing ESC (033) and moves the cursor
to the point needing correction and then inserts or deletes characters or words
as needed.
Most control commands accept an optional repeat
.Ar count
prior to the command.
.Pp
When in vi mode on most systems, canonical processing is initially enabled and
the command is echoed again if the speed is 1200 baud or greater and it
contains any control characters or less than one second has elapsed since the
prompt was printed.
The ESC character terminates canonical processing for the remainder of the
command and the user can then modify the command line.
This scheme has the advantages of canonical processing with the type-ahead
echoing of raw mode.
.Pp
If the option
.Sy viraw
is also set, the terminal is always have canonical processing disabled.
This mode is implicit for systems that do not support two alternate end of line
delimiters, and might be helpful for certain terminals.
.Ss "Input Edit Commands"
By default the editor is in input mode.
.Pp
The following input edit commands are supported:
.Bl -tag -width Ds
.It Sy ERASE
User defined erase character as defined by the
.Xr stty 1
command, usually
.Sy ^H
or
.Sy # .
Delete previous character.
.It Sy ^W
Delete the previous blank separated word.
On some systems the
.Sy viraw
option might be required for this to work.
.It Sy EOF
As the first character of the line causes the shell to terminate unless the
.Sy ignoreeof
option is set.
Otherwise this character is ignored.
.It Ar lnext
User defined literal next character as defined by
.Xr stty 1
or
.Sy ^V
if not defined.
Removes the next character's editing features, if any.
On some systems the
.Sy viraw
option might be required for this to work.
.It Sy \e
Escape the next ERASE or KILL character.
.It Sy ^I Pq TAB
Attempts command or file name completion as described in this manual page and
returns to input mode.
If a partial completion occurs, repeating this behaves as if
.Sy \&=
were entered from control mode.
If no match is found or entered after SPACE, a TAB is inserted.
.El
.Ss "Motion Edit Commands"
The motion edit commands move the cursor.
.Pp
The following motion edit commands are supported:
.Bl -tag -width Ar
.It Oo Ar count Oc Ns Sy l
Move the cursor forward (right) one character.
.It Oo Ar count Oc Ns Sy [C
Move the cursor forward (right) one character.
.It Oo Ar count Oc Ns Sy w
Move the cursor forward one alphanumeric word.
.It Oo Ar count Oc Ns Sy W
Move the cursor to the beginning of the next word that follows a blank.
.It Oo Ar count Oc Ns Sy e
Move the cursor to the end of the word.
.It Oo Ar count Oc Ns Sy E
Move the cursor to the end of the current blank delimited word.
.It Oo Ar count Oc Ns Sy h
Move the cursor backward (left) one character.
.It Oo Ar count Oc Ns Sy [D
Move the cursor backward (left) one character.
.It Oo Ar count Oc Ns Sy b
Move the cursor backward one word.
.It Oo Ar count Oc Ns Sy B
Move the cursor to the preceding blank separated word.
.It Oo Ar count Oc Ns Sy \&|
Move the cursor to column
.Ar count .
.It Oo Ar count Oc Ns Sy f Ns Ar c
Find the next character
.Ar c
in the current line.
.It Oo Ar count Oc Ns Sy F Ns Ar c
Find the previous character
.Ar c
in the current line.
.It Oo Ar count Oc Ns Sy f Ns Ar c
Equivalent to
.Sy f
followed by
.Sy h .
.It Oo Ar count Oc Ns Sy T Ns Ar c
Equivalent to
.Sy F
followed by
.Sy l .
.It Oo Ar count Oc Ns Sy \&;
Repeat
.Ar count
times the last single character find command:
.Sy f ,
.Sy F ,
.Sy t ,
or
.Sy T .
.It Oo Ar count Oc Ns Sy \&,
Reverse the last single character find command
.Ar count
times.
.It Sy 0 Pq No zero
Move the cursor to the start of line.
.It Sy \&^
Move the cursor to the first non-blank character in the line.
.It Sy [H
Move the cursor to the first non-blank character in the line.
.It Sy \&$
Move the cursor to the end of the line.
.It Sy [Y
Move the cursor to the end of the line.
.It Sy \&%
Moves to the balancing
.Sy \&( ,
.Sy \&) ,
.Sy \&{ ,
.Sy \&} ,
.Sy \&[ ,
or
.Sy \&] .
If cursor is not on one of the characters described in this section, the
remainder of the line is searched for the first occurrence of one of the
characters first.
.El
.Ss "Search Edit Commands"
The search edit commands access your command history.
.Pp
The following search edit commands are supported:
.Bl -tag -width Ar
.It Oo Ar count Oc Ns Sy k
Fetch the previous command.
Each time
.Sy k
is entered, the previous command back in time is accessed.
.It Oo Ar count Oc Ns Sy \&-
Fetch the previous command.
Each time
.Sy \&-
is entered, the previous command back in time is accessed.
Equivalent to
.Sy k .
.It Oo Ar count Oc Ns Sy [A
Fetch the previous command.
Each time
.Sy [A
is entered, the previous command back in time is accessed.
Equivalent to
.Sy k .
.It Oo Ar count Oc Ns Sy j
Fetch the next command.
Each time
.Sy j
is entered, the next command forward
in time is accessed.
.It Oo Ar count Oc Ns Sy \&+
Fetch the next command.
Each time
.Sy \&+
is entered, the next command forward in time is accessed.
Equivalent to
.Sy j .
.It Oo Ar count Oc Ns Sy [B
Fetch the next command.
Each time
.Sy [B
is entered, the next command forward in time is accessed.
Equivalent to
.Sy j .
.It Oo Ar count Oc Ns Sy G
Fetch command number
.Ar count .
The default is the least recent history command.
.It Sy / Ns Ar string
Search backward through history for a previous command containing
.Ar string .
.Ar string
is terminated by a RETURN or NEWLINE.
If string is preceded by a
.Sy ^ ,
the matched line must begin with
.Ar string .
If
.Ar string
is null, the previous string is used.
.It Sy \&? Ns Ar string
Search forward through history for a previous command containing
.Ar string .
.Ar string
is terminated by a RETURN or NEWLINE.
If string is preceded by a
.Sy ^ ,
the matched line must begin with
.Ar string .
If
.Ar string
is null, the previous string is used.
.Pp
Same as
.Sy /
except that search is in the forward direction.
.It Sy n
Search in the backwards direction for the next match of the last pattern to
.Sy /
or
.Sy \&?
commands.
.It Sy N
Search in the forward direction for next match of the last pattern to
.Sy /
or
.Sy \&?
commands.
.El
.Ss "Text Modification Edit Commands"
The following commands modify the line:
.Pp
.Bl -tag -width Ar -compact
.It Sy a
Enter input mode and enter text after the current character.
.Pp
.It Sy A
Append text to the end of the line.
Equivalent to
.Sy $a .
.Pp
.It Oo Ar count Oc Ns Sy c Ns Ar motion
.It Sy c Ns Oo Ar count Oc Ns Ar motion
Delete current character through to the character that
.Ar motion
would move the cursor to, and enter input mode.
If
.Ar motion
is
.Sy c ,
the entire line is deleted and input mode is entered.
.Pp
.It Sy C
Delete the current character through to the end of line and enter input mode.
Equivalent to
.Sy c$ .
.Pp
.It Sy S
Equivalent to
.Sy cc .
.Pp
.It Oo Ar count Oc Ns Sy s
Replace characters under the cursor in input mode.
.Pp
.It Sy D Ns Oo Ar count Oc Ns Sy d Ns Ar motion
Delete the current character through to the end of line.
Equivalent to
.Sy d$ .
.Pp
.It Sy d Oo Ar count Oc Ns Ar motion
Delete current character through to the character that
.Ar motion
would move to.
If
.Ar motion
is
.Sy d ,
the entire line is deleted.
.Pp
.It Sy i
Enter input mode and insert text before the current character.
.Pp
.It Sy I
Insert text before the beginning of the line.
Equivalent to
.Sy 0i .
.Pp
.It Oo Ar count Oc Ns Sy P
Place the previous text modification before the cursor.
.Pp
.It Oo Ar count Oc Ns Sy p
Place the previous text modification after the cursor.
.Pp
.It Sy R
Enter input mode and replace characters on the screen with characters you type
overlay fashion.
.Pp
.It Oo Ar count Oc Ns Sy r Ns Ar c
Replace the
.Ar count
characters starting at the current cursor position with
.Ar c ,
and advance the cursor.
.Pp
.It Oo Ar count Oc Ns Sy x
Delete current character.
.Pp
.It Oo Ar count Oc Ns Sy X
Delete preceding character.
.Pp
.It Oo Ar count Oc Ns Sy \&.
Repeat the previous text modification command.
.Pp
.It Oo Ar count Oc Ns Sy \&~
Invert the case of the
.Ar count
characters starting at the current cursor
position and advance the cursor.
.Pp
.It Oo Ar count Oc Ns Sy \&_
Causes the
.Ar count
word of the previous command to be appended and input mode entered.
The last word is used if
.Ar count
is omitted.
.Pp
.It Sy \&*
Causes an
.Sy \&*
to be appended to the current word and file name generation attempted.
If no match is found, it rings the bell.
Otherwise, the word is replaced by the matching pattern and input mode is
entered.
.Pp
.It Sy \e
Command or file name completion as described in this manual page.
.El
.Ss "Other Edit Commands"
The following miscellaneous edit commands are supported:
.Pp
.Bl -tag -width Ar -compact
.It Oo Ar count Oc Ns Sy y Ns Ar motion
.It Sy y Ns Oo Ar count Oc Ns Ar motion
Yank the current character through to the character to which
.Ar motion
would move the cursor.
Put the yanked characters in the delete buffer.
The text and cursor position are unchanged.
.Pp
.It Sy yy
Yank the current line.
.Pp
.It Sy Y
Yank the current line from the current cursor location to the end of the line.
Equivalent to
.Sy y$ .
.Pp
.It Sy u
Undo the last text modifying command.
.Pp
.It Sy U
Undo all the text modifying commands performed on current line.
.Pp
.It Oo Ar count Oc Ns Sy V
Return the command:
.Pp
.D1 Ic hist Fl e No ${ Ns Ev VISUAL Ns :-${ Ns Ev EDITOR Ns :-vi}} Ar count
.Pp
in the input buffer.
If
.Ar count
is omitted, the current line is used.
.Pp
.It Sy ^L
Line feed and print the current line.
This command only works in control mode.
.Pp
.It Sy ^J
New line.
Execute the current line, regardless of mode.
.Pp
.It Sy ^M
Return.
Execute the current line, regardless of mode.
.Pp
.It Sy #
If the first character of the command is a
.Sy # ,
delete this
.Sy #
and each
.Sy #
that follows a NEWLINE.
.Pp
Otherwise, send the line after inserting a
.Sy #
in front of each line in the command.
.Pp
This is command is useful for causing the current line to be inserted in the
history as a comment and un-commenting previously commented commands in the
history file.
.Pp
.It Oo Ar count Oc Ns Sy \&=
If
.Ar count
is not specified, generate the list of matching commands or file names as
described in this manual page.
.Pp
Otherwise, replace the word at the current cursor location with the
.Ar count
item from the most recently generated command or file list.
If the cursor is not on a word, it is inserted after the current cursor
location.
.Pp
.It Sy @ Ns Ar letter
Search your alias list for an alias by the name
.Ar letter .
If an alias of this name is defined, insert its value on the input queue for
processing.
.Pp
.It Sy ^V
Display version of the shell.
.El
.Ss "Built-in Commands"
The following simple-commands are executed in the shell process.
Input and output redirection is permitted.
Unless otherwise indicated, the output is written on file descriptor
.Sy 1
and the exit status, when there is no syntax error, is
.Sy 0 .
Except for
.Sy \&: ,
.Sy true ,
.Sy false ,
.Sy echo ,
.Sy newgrp ,
and
.Sy login ,
all built-in commands accept
.Fl -
to indicate the end of options.
They also interpret the option
.Fl -man
as a request to display the manual page onto standard error and
.Fl \&?
as a help request which prints a usage message on standard error.
.Pp
In the list below, commands that are preceded by one or two
.Sy \&+
symbols are special built-in commands and are treated specially in the
following ways:
.Bl -enum -offset Ds
.It
Variable assignment lists preceding the command remain in effect when the
command completes.
.It
I/O redirections are processed after variable assignments.
.It
Errors cause a script that contains them to abort.
.It
They are not valid function names.
.It
Words following a command preceded by
.Sy ++
that are in the format of a variable assignment are expanded with the same
rules as a variable assignment.
This means that tilde substitution is performed after the
.Sy \&=
sign and field splitting and file name generation are not performed.
.El
.Pp
.Bl -tag -width Ds -compact
.It Sy + Ic \&: Op Ar arg No ...
The command only expands parameters.
.Pp
.It Sy + Ic \&. Ar name Op Ar arg No ...
If
.Ar name
is a function defined with the
.Ic function Ar name
reserved word syntax, the function is executed in the current environment
.Pq as if it had been defined with the Ar name Ns Sy () No syntax .
Otherwise if
.Ar name
refers to a file, the file is read in its entirety and the commands are
executed in the current shell environment.
The search path specified by
.Ev PATH
is used to find the directory containing the file.
If any arguments
.Ar arg
are specified, they become the positional parameters while processing the
.Ic \&.
command and the original positional parameters are restored upon completion.
Otherwise the positional parameters are unchanged.
The exit status is the exit status of the last command executed.
.Pp
.It Sy ++ Ic alias Oo Fl ptx Oc Oo Ar name Ns Oo Sy = Ns Ar value Oc Oc No ...
.Ic alias
with no arguments prints the list of aliases in the form
.Ar name Ns Sy = Ns Ar value
on standard output.
The
.Fl p
option causes the word alias to be inserted before each one.
When one or more arguments are specified, an alias is defined for each
.Ar name
whose
.Ar value
is specified.
A trailing space in
.Ar value
causes the next word to be checked for alias substitution.
The obsolete
.Fl t
option is used to set and list tracked aliases.
The value of a tracked alias is the full pathname corresponding to the
specified
.Ar name .
The value becomes undefined when the value of
.Ev PATH
is reset but the alias remains tracked.
Without the
.Fl t
option, for each
.Ar name
in the argument list for which no
.Ar value
is specified, the name and value of the alias is printed.
The obsolete
.Fl x
option has no effect.
The exit status is
.Sy non-zero
if a
.Ar name
is specified, but no value, and no alias has been defined for the
.Ar name .
.Pp
.It Ic bg Op Ar job No ...
This command is only on systems that support job control.
Puts each specified
.Ar job
into the background.
The current job is put in the background if
.Ar job
is not specified.
See the
.Sx Jobs
section of this manual page for a description of the format of
.Ar job .
.Pp
.It Sy + Ic break Op Ar n
Exit from the enclosing
.Ic for ,
.Ic while ,
.Ic until ,
or
.Ic select
loop, if any.
If
.Ar n
is specified, then break
.Ar n
levels.
.Pp
.It Ic builtin Oo Fl ds Oc Oo Fl f Ar file Oc Oo Ar name No ... Oc
If
.Ar name
is not specified, and no
.Fl f
option is specified, the built-ins are printed on standard output.
The
.Fl s
option prints only the special built-ins.
Otherwise, each
.Ar name
represents the pathname whose basename is the name of the built-in.
The entry point function name is determined by prepending
.Ar b_
to the built-in name.
A built-in specified by a pathname will only be executed when that pathname
would be found during the path search.
Built-ins found in libraries loaded via the
.Pa \&.paths
file will be associated with the pathname of the directory containing the
.Pa \&.paths
file.
.Pp
The ISO C/C++ prototype is
.Ft int
.Fo b_mycommand
.Fa "int argc"
.Fa "char **argv"
.Fa "Shbltin_t *context"
.Fc
for the built-in command
.Ic mycommand
where
.Fa argv
is an array of
.Fa argc
elements and
.Fa context
is an optional pointer to a
.Vt Shbltin_t
structure as described in
.In ast/shell.h
Special built-ins cannot be bound to a pathname or deleted.
The
.Fl d
option deletes each of the specified built-ins.
On systems that support dynamic loading, the
.Fl f
option names a shared library containing the code for built-ins.
The shared library prefix and/or suffix, which depend on the system, can be
omitted.
Once a library is loaded, its symbols become available for subsequent
invocations of
.Ic builtin .
Multiple libraries can be specified with separate invocations of the
.Ic builtin
command.
Libraries are searched in the reverse order in which they are specified.
When a library is loaded, it looks for a function in the library whose name is
.Fn lib_init
and invokes this function with an argument of
.Sy 0 .
.Pp
.It Ic cd Oo Fl LP Oc Op Ar arg
.It Ic cd Oo Fl LP Oc Ar old Ar new
This command has two forms.
.Pp
In the first form it changes the current directory to
.Ar arg .
If
.Ar arg
is a literal
.Sy \&- ,
the directory is changed to the previous directory.
The shell variable
.Ev HOME
is the default
.Ar arg .
The variable
.Ev PWD
is set to the current directory.
The shell variable
.Ev CDPATH
defines the search path for the directory containing
.Ar arg .
Alternative directory names are
separated by a colon
.Pq Sy \&: .
The default path is
.Dv NULL
(specifying the current directory).
The current directory is specified by a null path name, which can appear
immediately after the equal sign or between the colon delimiters anywhere else
in the path list.
If
.Ar arg
begins with a
.Sy / ,
the search path is not used.
Otherwise, each directory in the path is searched for
.Ar arg .
.Pp
The second form of
.Ic cd
substitutes the string
.Ar new
for the string
.Ar old
in the current directory name,
.Ev PWD ,
and tries to change to this new directory.
.Pp
By default, symbolic link names are treated literally when finding the
directory name.
This is equivalent to the
.Fl L
option.
The
.Fl P
option causes symbolic links to be resolved when determining the directory.
The last instance of
.Fl L
or
.Fl P
on the command line determines which method is used.
The
.Ic cd
command cannot be executed by
.Nm rksh93 .
.Pp
.It Ic command Oo Fl pvVx Oc Ar name Op Ar arg No ...
Without the
.Fl v
or
.Fl V
options, executes
.Ar name
with the arguments specified by
.Ar arg .
.Pp
The
.Fl p
option causes a default path to be searched rather than the one defined by the
value of
.Ev PATH .
Functions are not searched when finding
.Ar name .
In addition, if
.Ar name
refers to a special built-in, none of the special properties associated with
the leading daggers are honored.
For example, the predefined alias
.Sy redirect='command exec'
prevents a script from terminating when an invalid redirection is specified.
.Pp
With the
.Fl x
option, if command execution would result in a failure because there are too
many arguments,
.Er E2BIG ,
the shell invokes command
.Ar name
multiple times with a subset of the arguments on each invocation.
Arguments that occur prior to the first word that expands to multiple arguments
and after the last word that expands to multiple arguments are passed on each
invocation.
The exit status is the maximum invocation exit status.
.Pp
With the
.Fl v
option,
.Ic command
is equivalent to the built-in
.Ic whence
command described in this section.
The
.Fl V
option causes
.Ic command
to act like
.Ic whence -v .
.Pp
.It Sy + Ic continue Op Ar n
Resumes the next iteration of the enclosing
.Ic for ,
.Ic while ,
.Ic until ,
or
.Ic select
loop.
If
.Ar n
is specified, then resume at the
.Ar n Ns No th
enclosing loop.
.Pp
.It Ic disown Op Ar job No ...
Causes the shell not to send a
.Sy HUP
signal to each specified
.Ar job ,
or all active jobs if
.Ar job
is omitted, when a login shell terminates.
.Pp
.It Ic echo Op arg No ...
When the first
.Ar arg
does not begin with a
.Sy - ,
and none of the arguments contain a backslash
.Pq Sy \e ,
prints each of its arguments separated by a SPACE and terminated by a NEWLINE.
Otherwise, the behavior of
.Ic echo
is system dependent and
.Ic print
or
.Ic printf
described in this section should be used.
See
.Xr echo 1
for usage and description.
.Pp
.It Sy ++ Ic enum Oo Fl i Oc Ar type Ns Op Sy =( Ns Ar value No ... Ns Sy \&)
Creates a declaration command named type that is an integer type that allows
one of the specified values as enumeration names.
If
.Sy =( Ns Ar value No ... Ns Sy \&)
is omitted, then type must be an indexed array variable with at least two
elements and the values are taken from this array variable.
If
.Fl i
is specified the values are case insensitive.
.Pp
.It Sy + Ic eval Op arg No ...
The arguments are read as input to the shell and the resulting commands are
executed.
.Pp
.It Sy + Ic exec Oo Fl c Oc Oo Fl a Ar name No ... Oc Op Ar arg No ...
If
.Ar arg
is specified, the command specified by the arguments is executed in place of
this shell without creating a new process.
The
.Fl c
option causes the environment to be cleared before applying variable
assignments associated with the exec invocation.
The
.Fl a
option causes
.Ar name
rather than the first
.Ar arg ,
to become
.Fa argv[0]
for the new process.
Input and output arguments can appear and affect the current process.
If
.Ar arg
is not specified, the effect of this command is to modify file descriptors as
prescribed by the input/output redirection list.
In this case, any file descriptor numbers greater than
.Sy 2
that are opened with this mechanism are closed when invoking another program.
.Pp
.It Sy + Ic exit Op Ar n
Causes the shell to exit with the exit status specified by
.Ar n .
The value is the least significant 8 bits of the specified status.
If
.Ar n
is omitted, then the exit status is that of the last command executed.
An end-of-file also causes the shell to exit except for a shell which has the
.Sy ignoreeof
option turned on.
See
.Ic set .
.Pp
.It Sy ++ Ic export Oo Fl p Oc Oo Ar name Ns Oo Sy = Ns Ar value Oc Oc No ...
If
.Ar name
is not specified, the names and values of each variable with the export
attribute are printed with the values quoted in a manner that allows them to be
re-entered.
The
.Ic export
command is the same as
.Ic typeset -x
except that if you use
.Ic export
within a function, no local variable is created.
The
.Fl p
option causes the word export to be inserted before each one.
Otherwise, the specified
.Ar name
s are marked for automatic export to the environment of subsequently-executed
commands.
.Pp
.It Ic false
Does nothing, and exits
.Sy 1 .
Used with
.Ic until
for infinite loops.
.Pp
.It Ic fg Op Ar job No ...
This command is only on systems that support job control.
Each
.Ar job
specified is brought to the foreground and waited for in the specified order.
Otherwise, the current job is brought into the foreground.
See
.Sx Jobs
for a description of the format of
.Ar job .
.Pp
.It Ic getconf Oo Ar name Oo Ar pathname Oc Oc
Prints the current value of the configuration parameter specified by
.Ar name .
The configuration parameters are defined by the IEEE POSIX 1003.1
and IEEE POSIX 1003.2 standards.
See
.Xr pathconf 2
and
.Xr sysconf 3C .
.Pp
The
.Ar pathname
argument is required for parameters whose value depends on the location in the
file system.
If no arguments are specified,
.Ic getconf
prints the names and values of the current configuration parameters.
The pathname
.Pa /
is used for each of the parameters that requires
.Ar pathname .
.Pp
.It Ic getopts Oo Fl a Ar name Oc Ar optstring Ar vname Op Ar arg No ...
Checks
.Ar arg
for legal options.
If
.Ar arg
is omitted, the positional parameters are used.
An option argument begins with a
.Sy \&+
or a
.Sy \&- .
An option that does not begin with
.Sy \&+
or
.Sy \&-
or the argument
.Fl \-
ends the options.
Options beginning with
.Sy \&+
are only recognized when
.Ar optstring
begins with a
.Sy \&+ .
.Ar optstring
contains the letters that
.Sy getopts
recognizes.
If a letter is followed by a
.Sy \&: ,
that option is expected to have an argument.
The options can be separated from the argument by blanks.
The option
.Fl \&?
causes
.Ic getopts
to generate a usage message on standard error.
The
.Fl a
option can be used to specify the name to use for the usage message, which
defaults to
.Sy $0 .
.Ic getopts
places the next option letter it finds inside variable
.Ar vname
each time it is invoked.
The option letter is prepended with a
.Sy \&+
when
.Ar arg
begins with a
.Sy \&+ .
The index of the next
.Ar arg
is stored in
.Ev OPTIND .
The option argument, if any, gets stored in
.Ev OPTARG .
A leading \&: in
.Ar optstring
causes
.Ic getopts
to store the letter of an invalid option in
.Ev OPTARG ,
and to set
.Ar vname
to
.Sy \&?
for an unknown option and to
.Sy \&:
when a required option argument is missing.
Otherwise,
.Ic getopts
prints an error message.
The exit status is
.Sy non-zero
when there are no more options.
There is no way to specify any of the options
.Sy \&: ,
.Sy \&+ ,
.Sy \&- ,
.Sy \&? ,
.Sy \&[ ,
and
.Sy \&] .
The option
.Sy \&#
can only be specified as the first option.
.Pp
.It Ic hist Oo Fl e Ar ename Oc Oo Fl nlr Oc Oo Ar first Oo Ar last Oc Oc
.It Ic hist Fl s Oo Ar old Ns Sy = Ns Ar new Oc Oo Ar command Oc
In the first form, a range of commands from
.Ar first
to
.Ar last
is selected from the last
.Ev HISTSIZE
commands that were typed at the terminal.
The arguments
.Ar first
and
.Ar last
can be specified as a number or as a string.
A string is used to locate the most recent command starting with the
specified string.
A negative number is used as an offset to the current command number.
If the
.Fl l
option is selected, the commands are listed on standard output.
Otherwise, the editor program
.Ar ename
is invoked on a file containing these keyboard commands.
If
.Ar ename
is not supplied, then the value of the variable
.Ev HISTEDIT
is used.
If
.Ev HISTEDIT
is not set, then
.Ev FCEDIT
.Pq default Pa /bin/ed
is used as the editor.
When editing is complete, the edited command(s) is executed if the changes have
been saved.
If
.Ar last
is not specified, then it is set to
.Ar first .
If
.Ar first
is not specified, the default is the previous command for editing and
.Fl 16
for listing.
The option
.Fl r
reverses the order of the commands and the option
.Fl n
suppresses command numbers when listing.
In the second form,
.Ar command
is interpreted as
.Ar first
described in this section and defaults to the last command executed.
The resulting command is executed after the optional substitution
.Ar old Ns Sy = Ns Ar new
is performed.
.Pp
.It Ic jobs Fl lnp Op Ar job No ...
Lists information about each specified job, or all active jobs if
.Ar job
is omitted.
The
.Fl l
option lists process ids in addition to the normal information.
The
.Fl n
option only displays jobs that have stopped or exited since last notified.
The
.Fl p
option causes only the process group to be listed.
See
.Sx Jobs
for a description of the format of
.Ar job .
.Pp
.It Ic kill Oo Fl s Ar signame Oc Ar job No ...
.It Ic kill Oo Fl n Ar signum Oc Ar job No ...
.It Ic kill Fl Ll Op Ar sig No ...
Sends either the
.Sy TERM
(terminate) signal or the specified signal to the specified jobs or processes.
Signals are either specified by number with the
.Fl n
option or by name with the
.Fl s
option
.Po
as specified in
.In signal.h ,
stripped of the prefix
.Ql SIG
with the exception that
.Sy SIGCLD
is named
.Sy CHLD
.Pc .
For backwards compatibility, the
.Sy n
and
.Sy s
can be omitted and the number or name placed immediately after the
.Fl .
If the signal being sent is
.Sy TERM
(terminate) or
.Sy HUP
(hang up), then the job or process is sent a
.Sy CONT
(continue) signal if it is stopped.
The argument
.Ar job
can be the process id of a process that is not a member of one of the active
jobs.
See
.Sx Jobs
for a description of the format of
.Ar job .
In the third form,
.Ic kill Fl l
or
.Ic kill Fl L ,
if
.Ar sig
is not specified, the signal names are listed.
The
.Fl l
option
lists only the signal names whereas
.Fl L
lists each signal name and corresponding number.
Otherwise, for each
.Ar sig
that is a name, the corresponding signal number is listed.
For each
.Ar sig
that is a number, the signal name corresponding to the least significant 8 bits
of
.Ar sig
is listed.
.Pp
.It Ic let Op Ar arg No ...
Each
.Ar arg
is a separate arithmetic expression to be evaluated.
.Ic let
only recognizes octal constants starting with
.Sy 0
when the
.Ic set
option
.Sy letoctal
is on.
See the
.Sx Arithmetic Evaluation
section of this manual page for a description of arithmetic expression
evaluation.
The exit status is
.Sy 0
if the value of the last expression is
.Sy non-zero ,
and
.Sy 1
otherwise.
.Pp
.It Sy + Ic newgrp Op arg No ...
Equivalent to
.Ic exec Pa /bin/newgrp Ar arg No ...
.Pp
.It Xo
.Ic print
.Op Fl CRenprsv
.Op Fl u Ar unit
.Op Fl f Ar format
.Op Ar arg No ...
.Xc
With no options or with option
.Sy -
or
.Fl \- ,
each
.Ar arg
is printed on standard output.
The
.Fl f
option causes the arguments to be printed as described by
.Ic printf .
In this case, any
.Fl e ,
.Fl n ,
.Fl r ,
or
.Fl R
options are ignored.
Otherwise, unless the
.Fl R
or
.Fl r
options are specified, the following escape conventions are applied:
.Bl -tag -width Ds
.It Sy \ea
Alert character
.Pq Sy ASCII 007
.It Sy \eb
Backspace character
.Pq Sy ASCII 010
.It Sy \ec
Causes print to end without processing more arguments and not adding a NEWLINE
.It Sy \ef
Form-feed character
.Pq Sy ASCII 014
.It Sy \en
NEWLINE character
.Pq Sy ASCII 012
.It Sy \er
RETURN character
.Pq Sy ASCII 015
.It Sy \et
TAB character
.Pq Sy ASCII 011
.It Sy \ev
Vertical TAB character
.Pq Sy ASCII 013
.It Sy \eE
Escape character
.Pq Sy ASCII 033
.It Sy \e\e
Backslash character
.Sy \e
.It Sy \e0 Ns Ar x
Character defined by the 1, 2, or 3-digit octal string specified by
.Ar x
.El
.Pp
The
.Fl R
option prints all subsequent arguments and options other than
.Fl n .
The
.Fl e
causes the escape conventions to be applied.
This is the default behavior.
It reverses the effect of an earlier
.Fl r .
The
.Fl p
option causes the arguments to be written onto the pipe of the process spawned
with
.Sy |&
instead of standard output.
The
.Fl v
option treats each
.Ar arg
as a variable name and writes the value in the
.Ic printf Cm \&%B
format.
The
.Fl C
option treats each
.Ar arg
as a variable name and writes the values in the
.Ic printf Cm \&%#B
format.
The
.Fl s
option causes the arguments to be written onto the history file instead of
standard output.
The
.Fl u
option can be used to specify a one digit file descriptor unit number
.Ar unit
on which the output is placed.
The default is
.Sy 1 .
If the option
.Fl n
is used, no NEWLINE is added to the output.
.Pp
.It Ic printf Ar format Op Ar arg No ...
The arguments
.Ar arg
are printed on standard output in accordance with the
.Sy ANSI-C
formatting rules associated with the format string
.Ar format .
If the number of arguments exceeds the number of format specifications, the
format string is reused to format remaining arguments.
The following extensions can also be used:
.Bl -tag -width Ds
.It Sy %b
A
.Sy %b
format can be used instead of
.Sy %s
to cause escape sequences in the corresponding
.Ar arg
to be expanded as described in
.Ic print .
.It Sy \&%B
A
.Sy \&%B
option causes each of the arguments to be treated as variable names and the
binary value of the variables is printed.
This is most useful for variables with an attribute of b.
.It Sy \&%H
A
.Sy \&%H
format can be used instead of
.Sy %s
to cause characters in
.Ar arg
that are special in
.Sy HTML
and
.Sy XML
to be output as their entity name.
The alternate flag
.Sy #
formats the output for use as a URI.
.It Sy \&%P
A
.Sy \&%P
format can be used instead of
.Sy \&%s
to cause
.Ar arg
to be interpreted as an extended regular expression and be printed as a shell
pattern.
.It Sy \&%R
A
.Sy \&%R
format can be used instead of
.Sy \&%s
to cause
.Ar arg
to be interpreted as a shell pattern and to be printed as an extended regular
expression.
.It Sy \&%q
A
.Sy \&%q
format can be used instead of
.Sy \&%
s to cause the resulting string to be quoted in a manner than can be input
again to the shell.
When
.Sy q
is preceded by the alternative format specifier,
.Sy # ,
the string is quoted in manner suitable for a field in a
.Sy .csv
format file.
.It Sy \&% Ns Oo Sy \&( Ns Ar date-format Ns Sy \&) Oc Ns Sy T
A
.Sy \&% Ns Oo Sy \&( Ns Ar date-format Ns Sy \&) Oc Ns Sy T
format can be used to treat an argument as a date/time string and to format the
date/time according to the
.Ar date-format
as defined for the
.Xr date 1
command.
For example,
.Sq printf '%(%s)T' now
would print the current time in UNIX timestamp format
.Pq seconds since 00:00:00 UTC, January 1, 1970 .
.It Sy %Z
A
.Sy %Z
format outputs a byte whose value is 0.
.It Sy %d
The precision field of the %d format can be followed by a \&. and the output
base.
In this case, the
.Sy #
flag character causes
.Sy base Ar #
to be prepended.
.It Sy #
The
.Sy #
flag, when used with the
.Sy %d
format without an output base, displays the output in powers of 1000 indicated
by one of the following suffixes:
.Sy k M G T P E ,
and when used with the
.Sy %i
format displays the output in powers of 1024 indicated by one of the following
suffixes:
.Sy Ki Mi Gi Ti Pi Ei .
.It Sy =
The
.Sy =
flag centers the output within the specified field width.
.It Sy L
The
.Sy L
flag, when used with the
.Sy %c
or
.Sy %s
formats, treats precision as character width instead of byte count.
.It Sy \&,
The
.Sy \&,
flag, when used with the
.Sy %d
or
.Sy %f
formats, separates groups of digits with the grouping delimiter
.Po Sq Sy \&,
in groups of 3 in the C locale
.Pc .
.El
.Pp
.It Ic pwd Op Fl LP
Outputs the value of the current working directory.
The
.Fl L
option is the default.
It prints the logical name of the current directory.
If the
.Fl P
option is specified, all symbolic links are resolved from the name.
The last instance of
.Fl L
or
.Fl P
on the command line determines which method is used.
.Pp
.It Xo
.Bk -words
.Ic read Op Fl ACSprsv
.Op Fl d Ar delim
.Op Fl n Ar n | Fl N Ar n
.Op Fl t Ar timeout
.Op Fl u Ar unit
.Op Ar vname Ns Sy \&? Ns Ar prompt
.Op Ar name No ...
.Ek
.Xc
.Pp
The shell input mechanism.
One line is read and is broken up into fields using the characters in
.Ev IFS
as separators.
The escape character,
.Sy \e ,
is used to remove any special meaning for the next character and for line
continuation.
The
.Fl d
option causes the read to continue to the first character of
.Ar delim
rather than NEWLINE.
The
.Fl n
option causes at most
.Ar n
bytes to read rather a full line but returns when reading from a slow device as
soon as any characters have been read.
The
.Fl N
option causes exactly
.Ar n
to be read unless an end-of-file has been encountered or the read times out
because of the
.Fl t
option.
In raw mode,
.Fl r ,
the
.Sy \e
character is not treated specially.
The first field is assigned to the first
.Ar vname ,
the second field to the second
.Ar vname ,
etc., with leftover fields assigned to the last
.Ar vname .
When
.Ar vname
has the binary attribute and
.Fl n
or
.Fl N
is specified, the bytes that are read are stored directly into the variable.
If
.Fl v
is specified, then the value of the first
.Ar vname
is used as a default value when reading from a terminal device.
The
.Fl A
option causes the variable
.Ar vname
to be unset and each field that is read to be stored in successive elements of
the indexed array
.Ar vname .
The
.Fl C
option causes the variable vname to be read as a compound variable.
Blanks will be ignored when finding the beginning open parenthesis.
The
.Fl S
option causes the line to be treated like a record in a .csv format file so
that double quotes can be used to allow the delimiter character and the
new-line character to appear within a field.
The
.Fl p
option causes the input line to be taken from the input pipe of a process
spawned by the shell using
.Sy |& .
If the
.Fl s
option is present, the input is saved as a command in the history file.
The option
.Fl u
can be used to specify a one digit file descriptor unit
.Ar unit
to read from.
The file descriptor can be opened with the
.Ic exec
special built-in command.
The default value of unit
.Ar n
is
.Sy 0 .
The option
.Fl t
is used to specify a time out in seconds when reading from a terminal or pipe.
If
.Ar vname
is omitted, then
.Ev REPLY
is used as the default
.Ar vname .
An end-of-file with the
.Fl p
option causes cleanup for this process so that another can be spawned.
If the first argument contains a
.Sy \&? ,
the remainder of this word is used as a prompt on standard error when the shell
is interactive.
The exit status is
.Sy 0
unless an end-of-file is encountered or read has timed out.
.Pp
.It Xo
.Sy ++ Ic readonly
.Op Fl p
.Oo Ar vname Ns Oo Sy = Ns Ar value Oc Oc ...
.Xc
If
.Ar vname
is not specified, the names and values of each variable with the read-only
attribute is printed with the values quoted in a manner that allows them to be
input again.
The
.Fl p
option causes the word
.Ic readonly
to be inserted before each one.
Otherwise, the specified
.Ar vname Ns No s
are marked
.Ic readonly
and these names cannot be changed by subsequent assignment.
.Pp
.It Sy + Ic return Op Ar n
Causes a shell function or script to return to the invoking script with the
exit status specified by
.Ar n .
The value is the least significant 8 bits of the specified status.
If
.Sy n
is omitted, then the return status is that of the last command executed.
If return is invoked while not in a function or a script, then it behaves the
same as exit.
.Pp
.It Xo
.Sy + Ic set
.Op Sy + Ns Fl BCGabefhkmnoprstuvx
.Oo Sy + Ns Fl o Oo Ar option Oc Oc ...
.Op Sy + Ns Fl A Ar vname
.Op Ar arg No ...
.Xc
The
.Ic set
command supports the following options:
.Bl -tag -width Ds
.It Fl a
All subsequent variables that are defined are automatically exported.
.It Fl A
Array assignment.
Unset the variable
.Ar vname
and assign values sequentially from the
.Ar arg
list.
If
.Sy +A
is used, the variable
.Ar vname
is not unset first.
.It Fl b
Prints job completion messages as soon as a background job changes state rather
than waiting for the next prompt.
.It Fl B
Enable brace pattern field generation.
This is the default behavior.
.It Fl C
Prevents redirection
.Pq Sy \&>
from truncating existing files.
Files that are created are opened with the
.Sy O_EXCL
mode.
Requires
.Sy >|
to truncate a file when turned on.
.It Fl e
Unless contained in a
.Sy ||
or
.Sy &&
command, or the command following an
.Ic if ,
.Ic while
or
.Ic until
command or in the pipeline following
.Sy \&! ,
if a command has a non-zero exit status, execute the
.Sy ERR
trap, if set, and exit.
This mode is disabled while reading profiles.
.It Fl f
Disables file name generation.
.It Fl G
Causes the pattern
.Sy \&**
by itself to match files and zero or more directories and subdirectories when
used for file name generation.
If followed by a
.Sy /
only directories and subdirectories are matched.
.It Fl h
Each command becomes a tracked alias when first encountered.
.It Fl k
Obsolete.
All variable assignment arguments are placed in the environment for a command,
not just those that precede the command name.
.It Fl m
Background jobs run in a separate process group and a line prints upon
completion.
The exit status of background jobs is reported in a completion message.
On systems with job control, this option is turned on automatically for
interactive shells.
.It Fl n
Read commands and check them for syntax errors, but do not execute them.
Ignored for interactive shells.
.It Fl o
If no option name is supplied, the list of options and their current settings
are written to standard output.
When invoked with a
.Sy \&+ ,
the options are written in a format that can be input again to the shell to
restore the settings.
This option can be repeated to enable or disable multiple options.
.Pp
The following argument can be one of the following option names:
.Bl -tag -width Ar
.It Cm allexport
Same as
.Fl a .
.It Cm bgnice
All background jobs are run at a lower priority.
This is the default mode.
.It Cm braceexpand
Same as
.Fl B .
.It Cm emacs
Puts you in an
.Sy emacs
style inline editor for command entry.
.It Cm errexit
Same as
.Fl e .
.It Cm globstar
Same as
.Fl G .
.It Cm gmacs
Puts you in a
.Sy gmacs
style inline editor for command entry.
.It Cm ignoreeof
The shell does not exit on end-of-file.
The command
.Ic exit
must be used.
.It Cm keyword
Same as
.Fl k .
.It Cm letoctal
The
.Ic let
command allows octal constants starting with
.Sy 0 .
.It Cm markdirs
All directory names resulting from file name generation have a trailing /
appended.
.It Cm monitor
Same as
.Fl m .
.It Cm multiline
The built-in editors use multiple lines on the screen for lines that are longer
than the width of the screen.
This might not work for all terminals.
.It Cm noclobber
Same as
.Fl C .
.It Cm noexec
Same as
.Fl n .
.It Cm noglob
Same as
.Fl f .
.It Cm nolog
Do not save function definitions in the history file.
.It Cm notify
Same as
.Fl b .
.It Cm nounset
Same as
.Fl u .
.It Cm pipefail
A pipeline does not complete until all components of the pipeline have
completed, and the return value is the value of the last
.Sy non-zero
command to fail or zero if no command has failed.
.It Cm privileged
Same as
.Fl p .
.It Cm showme
When enabled, simple commands or pipelines preceded by a a semicolon
.Pq \&;
is displayed as if the
.Cm xtrace
option were enabled but is not executed.
Otherwise, the leading
.Sy \&;
is ignored.
.It Cm trackall
Same as
.Fl h .
.It Cm verbose
Same as
.Fl v .
.It Cm vi
Puts you in insert mode of a
.Sy vi
style inline editor until you hit the escape character 033.
This puts you in control mode.
A return sends the line.
.It Cm viraw
Each character is processed as it is typed in
.Sy vi
mode.
.It Cm xtrace
Same as
.Fl x .
.El
.Pp
If no option name is supplied, the current options settings are printed.
.It Fl p
Disables processing of the
.Pa $HOME/.profile
file and uses the file
.Pa /etc/suid_profile
instead of the
.Ev ENV
file.
This mode is on whenever the effective
.Sy uid Pq Sy gid
is not equal to the real
.Sy uid Pq Sy gid .
Turning this off causes the effective
.Sy uid
and
.Sy gid
to be set to the real
.Sy uid
and
.Sy gid .
.It Fl r
Enables the restricted shell.
This option cannot be unset once set.
.It Fl s
Sort the positional parameters lexicographically.
.It Fl t
Obsolete.
Exit after reading and executing one command.
.It Fl u
Treat
.Sy unset
parameters as an error when substituting.
.It Fl v
Print shell input lines as they are read.
.It Fl x
Print commands and their arguments as they are executed.
.It Fl \-
Do not change any of the options.
This is useful in setting
.Sy $1
to a value
beginning with
.Sy \- .
If no arguments follow this option then the positional parameters are unset.
.El
.Pp
As an obsolete feature, if the first
.Ar arg
is
.Sy \-
then the
.Fl x
and
.Fl v
options are turned off and the next
.Ar arg
is treated as the first argument.
Using
.Sy \&+
rather than
.Fl
causes these options to be turned off.
These options can also be used upon invocation of the shell.
The current set of options can be found in
.Sy $- .
Unless
.Fl A
is specified, the remaining arguments are positional parameters and are
assigned, in order, to
.Sy $1 $2 \&... .
If no arguments are specified, then
the names and values of all variables are printed on the standard output.
.Pp
.It Sy + Ic shift Op Ar n
The positional parameters from
.Sy $ Ns Ar n Ns Sy +1
are renamed
.Sy $1 \&... ,
the default
.Ar n
is
.Sy 1 .
The parameter
.Ar n
can be any arithmetic expression that evaluates to a non-negative number less
than or equal to
.Sy $# .
.Pp
.It Ic sleep Ar seconds
Suspends execution for the number of decimal seconds or fractions of a second
specified by
.Ar seconds .
.Pp
.It Sy + Ic trap Oo Fl p Oc Oo Ar action Oc Oo Ar sig Oc ...
The
.Fl p
option causes the trap action associated with each trap as specified by the
arguments to be printed with appropriate quoting.
Otherwise,
.Ar action
is processed as if it were an argument to
.Ic eval
when the shell receives signal(s)
.Ar sig .
Each
.Ar sig
can be specified as a number or as the name of the signal.
Trap commands are executed in order of signal number.
Any attempt to set a trap on a signal that was ignored on entry to the current
shell is ineffective.
If
.Ar action
is omitted and the first
.Ar sig
is a number, or if
.Ar action
is
.Sy - ,
then the trap(s) for each
.Ar sig
are reset to their original values.
If
.Ar action
is the null string then this signal is ignored by the shell and by the commands
it invokes.
If
.Ar sig
is
.Sy ERR
then
.Ar action
is executed whenever a command has a
.Sy non-zero
exit status.
If
.Ar sig
is
.Sy DEBUG
then
.Ar action
is executed before each command.
The variable
.Sy \&.sh.command
contains the contents of the current command line when
.Ar action
is running.
If
.Ar sig
is
.Sy 0
or
.Sy EXIT
and the trap statement is executed inside the body of a function defined with
the
.Ic function Ar name
syntax, then the command
.Ar action
is executed after the function completes.
If
.Ar sig
is
.Sy 0
or
.Sy EXIT
for a trap set outside any function then the command
.Ar action
is executed on exit from the shell.
If
.Ar sig
is
.Sy KEYBD ,
then
.Ar action
is executed whenever a key is read while in
.Sy emacs ,
.Sy gmacs ,
or
.Sy vi
mode.
The
.Sy trap
command with no arguments prints a list of commands associated with each signal
number.
.Pp
.It Ic true
Does nothing, and exits
.Sy 0 .
Used with while for infinite loops.
.Pp
.It Xo
.Bk -words
.Sy ++ Ic typeset
.Op Sy + Ns Fl ACHSfblmnprtux
.Op Sy + Ns Fl EFLRXZi Ns Op Ar n
.Op Sy + Ns Fl M Op Ar mapname
.Op Fl T Op Ar tname Ns Sy =( Ns Ar assign_list Ns Sy \&)
.Op Fl h Ar str
.Op Fl a Op Ar type
.Op Ar vname Ns Op Sy = Ns Ar value
.Ek
.Xc
.Pp
Sets attributes and values for shell variables and functions.
When invoked inside a function defined with the
.Sy function Ar name
syntax, a new instance of the variable
.Ar vname
is created, and the variable's value and type are restored when the function
completes.
.Pp
Using
.Sy +
rather than
.Fl
causes these options to be turned off.
If no
.Ar vname
arguments are specified, a list of
.Ar vname Ns No s
.Po and optionally the
.Ar value Ns No s
.Pc
of the variables is printed.
Using
.Sy +
rather than
.Fl -
keeps the values from being printed.
The
.Fl p
option causes
.Ic typeset
followed by the option letters to be printed before each name rather than the
names of the options.
If any option other than
.Fl p
is specified, only those variables which have all of the specified options are
printed.
Otherwise, the
.Ar vname Ns No s
and
.Ar attribute Ns No s
of all variables that have attributes are printed.
.Pp
The following list of attributes can be specified:
.Bl -tag -width Ds
.It Fl a
Declares
.Ar vname
to be an indexed array.
This is optional unless except for compound variable assignments.
.It Fl A
Declares
.Ar vname
to be an associative array.
Sub-scripts are strings rather than arithmetic expressions.
.It Fl b
The variable can hold any number of bytes of data.
The data can be text or binary.
The value is represented by the
.Sy base64
encoding of the data.
If
.Fl Z
is also specified, the size in bytes of the data in the buffer is determined by
the size associated with the
.Fl Z .
If the
.Sy base64
string assigned results in more data, it is truncated.
Otherwise, it is filled with bytes whose value is zero.
The
.Ic printf
format
.Cm \&%B
can be used to output the actual data in this buffer instead of the
.Sy base64
encoding of the data.
.It Fl C
Causes each
.Ar vname
to be a compound variable.
If
.Ar value
names a compound variable it is copied into
.Ar vname .
Otherwise, it unsets each
.Ar vname .
.It Fl E
Declares
.Ar vname
to be a double precision floating point number.
If
.Ar n
is
.Sy non-zero ,
it defines the number of significant figures that are used when expanding
.Ar vname .
Otherwise, ten significant figures is used.
.It Fl f
The names refer to function names rather than variable names.
No assignments can be made and the only other valid options are
.Fl t ,
.Fl u ,
and
.Fl x .
The
.Fl t
option turns on execution tracing for this function.
The
.Fl u
option causes this function to be marked undefined.
The
.Ev FPATH
variable is searched to find the function definition when the function is
referenced.
If no options other than
.Fl f
are specified, then the function definition is displayed on standard output.
If
.Sy +f
is specified, then a line containing the function name followed by a shell
comment containing the line number and path name of the file where this
function was defined, if any, is displayed.
The names refer to function names rather than variable names.
No assignments can be made and the only other valid options are
.Fl S ,
.Fl t ,
.Fl u
and
.Fl x .
The
.Fl S
option can be used with discipline functions defined in a type to indicate that
the function is static.
For a static function, the same method will be used by all instances of that
type no matter which instance references it.
In addition, it can only use value of variables from the original type
definition.
These discipline functions cannot be redefined in any type instance.
The
.Fl t
option turns on execution tracing for this function.
The
.Fl u
option causes this function to be marked undefined.
The
.Ev FPATH
variable will be searched to find the function definition when the function is
referenced.
If no options other than
.Fl f
are specified, then the function definition will be displayed on standard
output.
If
.Sy +f
is specified, then a line containing the function name followed by a shell
comment containing the line number and path name of the file where this
function was defined, if any, is displayed.
The exit status can be used to determine whether the function is defined so
that
.Ic typeset Fl f Sy .sh.math\&. Ns Ar name
will return
.Sy 0
when math function
.Ar name
is defined and non-zero otherwise.
.Pp
The
.Fl i
attribute cannot be specified with
.Fl f .
.It Fl F
Declares
.Ar vname
to be a double precision floating point number.
If
.Ar n
is
.Sy non-zero ,
it defines the number of places after the decimal point that are used when
expanding
.Ar vname .
Otherwise ten places after the decimal point is used.
.It Fl h
Used within type definitions to add information when generating information
about the sub-variable on the man page.
It is ignored when used outside of a type definition.
When used with
.Fl f
the information is associated with the corresponding discipline function.
.It Fl H
This option provides UNIX to hostname file mapping on non-UNIX machines.
.It Fl i
Declares
.Ar vname
to be represented internally as integer.
The right hand side of an assignment is evaluated as an arithmetic expression
when assigning to an integer.
If
.Ar n
is
.Sy non-zero ,
it defines the output arithmetic base, otherwise the output base is ten.
.Pp
The
.Fl i
attribute cannot be specified along with
.Fl R ,
.Fl L ,
.Fl Z ,
or
.Fl f .
.It Fl l
Used with
.Fl i ,
.Fl E
or
.Fl F
to indicate long integer, or long float.
Otherwise, all upper-case characters are converted to lower-case.
The upper-case option,
.Fl u ,
is turned off.
Equivalent to
.Fl M Cm tolower .
.It Fl L
Left justify and remove leading blanks from
.Ar value .
If
.Ar n
is
.Sy non-zero ,
it defines the width of the field, otherwise it is determined by the width of
the value of first assignment.
When the variable is assigned to, it is filled on the right with blanks or
truncated, if necessary, to fit into the field.
The
.Fl R
option is turned off.
.Pp
The
.Fl i
attribute cannot be specified with
.Fl L .
.It Fl m
moves or renames the variable.
The value is the name of a variable whose value will be moved to
.Ar vname .
The original variable will be unset.
Cannot be used with any other options.
.It Fl M
Use the character mapping
.Ar mapping
such as
.Sy tolower
and
.Sy toupper
when assigning a value to each of the specified operands.
When
.Ar mapping
is specified and there are not operands, all variables that use this mapping
are written to standard output.
When
.Ar mapping
is omitted and there are no operands, all mapped variables are written to
standard output.
.It Fl n
Declares
.Ar vname
to be a reference to the variable whose name is defined by the value of
variable
.Ar vname .
This is usually used to reference a variable inside a function whose name has
been passed as an argument.
.It Fl p
The name, attributes and values for the given
.Ar vname
are written on standard output in a form that can be used as shell input.
If
.Sy +p
is specified, then the values are not displayed.
.It Fl R
Right justify and fill with leading blanks.
If
.Ar n
is
.Sy non-zero ,
it defines the width of the field, otherwise it is determined by the width of
the value of first assignment.
The field is left filled with blanks or truncated from the end if the variable
is reassigned.
The
.Fl L
option is turned off.
.Pp
The
.Fl i
attribute cannot be specified with
.Fl R .
.It Fl r
The specified
.Ar vname Ns No s
are marked read-only and these names cannot be changed by subsequent
assignment.
.It Fl S
When used within the
.Ar assign_list
of a type definition, it causes the specified sub-variable to be shared by all
instances of the type.
When used inside a function defined with the
.Ic function
reserved word, the specified variables will have
.Em function static
scope.
Otherwise, the variable is unset prior to processing the assignment list.
.It Fl t
Tags the variables.
Tags are user definable and have no special meaning to the shell.
.It Fl T
If followed by
.Ar tname ,
it creates a type named by
.Ar tname
using the compound assignment
.Ar assign_list
to
.Ar tname .
Otherwise, it writes all
the type definitions to standard output.
.It Fl u
When given along with
.Fl i
specifies unsigned integer.
Otherwise, all lower-case characters are converted to upper-case.
The lower-case option,
.Fl l ,
is turned off.
Equivalent to
.Fl M Cm toupper .
.It Fl x
The specified
.Ar vname Ns No s
are marked for automatic export to the environment of subsequently-executed
commands.
Variables whose names contain a
.Sy \&.
cannot be exported.
.It Fl X
Declares
.Ar vname
to be a double precision floating point number and expands using the
.Cm %a
format of ISO-C99.
If
.Ar n
is non-zero, it defines the number of hex digits after the radix point that is
used when expanding
.Ar vname .
The default is 10.
.It Fl Z
Right justify and fill with leading zeros if the first non-blank character is a
digit and the
.Fl L
option has not been set.
Remove leading zeros if the
.Fl L
option is also set.
If
.Ar n
is
.Sy non-zero ,
it defines the width of the field, otherwise it is determined by the width of
the value of first assignment.
.Pp
The
.Fl i
attribute cannot be specified with
.Fl Z .
.El
.Pp
.It Ic ulimit Oo Fl HSacdfmnpstv Oc Op Ar limit
Set or display a resource limit.
Many systems do not support one or more of these limits.
The limit for a specified resource is set when
.Ar limit
is specified.
The value of
.Ar limit
can be a number in the unit specified with each resource, or the value
unlimited.
When more than one resource is specified, then the limit name and unit is
printed before the value.
.Pp
If no option is specified,
.Fl f
is assumed.
.Pp
The following are the available resource limits:
.Bl -tag -width Ds
.It Fl a
Lists all of the current resource limits.
.It Fl c
The number of 512-byte blocks on the size of core dumps.
.It Fl d
The number of Kbytes on the size of the data area.
.It Fl f
The number of 512-byte blocks on files that can be written by the current
process or by child processes (files of any size can be read).
.It Fl H
Specifies a hard limit for the specified resource.
.Pp
A hard limit cannot be increased once it is set.
.Pp
If neither the
.Fl H
nor
.Fl S
option is specified, the limit applies to
both.
The current resource limit is printed when
.Ar limit
is omitted.
In this case, the soft limit is printed unless
.Fl H
is specified.
.It Fl m
The number of Kbytes on the size of physical memory.
.It Fl n
The number of file descriptors plus 1.
.It Fl p
The number of 512-byte blocks for pipe buffering.
.It Fl s
The number of Kbytes on the size of the stack area.
.It Fl S
Specifies a soft limit for the specified resource.
.Pp
A soft limit can be increased up to the value of the hard limit.
.Pp
If neither the
.Fl H
nor
.Fl S
option is specified, the limit applies to both.
The current resource limit is printed when
.Ar limit
is omitted.
In this case, the soft limit is printed unless
.Fl H
is specified.
.It Fl t
The number of CPU seconds to be used by each process.
.It Fl v
The number of Kbytes for virtual memory.
.El
.Pp
.It Ic umask Oo Fl S Oc Op Ar mask
The user file-creation mask is set to
.Ar mask .
.Ar mask
can either be an octal number or a symbolic value as described in
.Xr chmod 1 .
.Pp
If a symbolic value is specified, the new
.Sy umask
value is the complement of the result of applying
.Ar mask
to the complement of the previous
.Sy umask
value.
If
.Ar mask
is omitted, the current value of the mask is printed.
The
.Fl S
option causes the mode to be printed as a symbolic value.
Otherwise, the mask is printed in octal.
.Pp
See
.Xr umask 2
.Pp
.It Sy + Ic unalias Oo Fl a Oc Ar name No ...
The aliases specified by the list of
.Ar name Ns No s
are removed from the alias list.
The
.Fl a
option causes all the aliases to be unset.
.Pp
.It Sy + Ic unset Oo Fl fnv Oc Ar vname No ...
The variables specified by the list of
.Ar vname Ns No s
are unassigned, i.e., their values and attributes are erased.
Read-only variables cannot be unset.
If the
.Fl f
option is set, then the names refer to function names.
If the
.Fl v
option is set, then the names refer to variable names.
The
.Fl f
option overrides
.Fl v .
If
.Fl n
is set and
.Ar name
is a name reference, then
.Ar name
is unset rather than the variable that it references.
The default is equivalent to
.Fl v .
Unsetting
.Ev LINENO ,
.Ev MAILCHECK ,
.Ev OPTARG ,
.Ev OPTIND ,
.Ev RANDOM ,
.Ev SECONDS ,
.Ev TMOUT ,
and
.Ev _
removes their special meaning even if they are subsequently assigned to.
.Pp
.It Ic wait Op Ar job
Wait for the specified job and report its termination status.
If
.Ar job
is not specified, then all currently active child processes are waited for.
The exit status from this command is that of the last process waited for if
.Ar job
is specified; otherwise it is zero.
See
.Sx Jobs
for a description of the format of
.Ar job .
.Pp
.It Ic whence Oo Fl afpv Oc Ar name No ...
For each
.Ar name ,
indicate how it would be interpreted if used as a command name.
The
.Fl v
option produces a more verbose report.
The
.Fl f
option skips the search for functions.
The
.Fl p
option does a path search for
.Ar name
even if name is an alias, a function, or a reserved word.
The
.Fl a
option is similar to the
.Fl v
option but causes all interpretations of the specified name to be reported.
.El
.Ss "Invocation"
If the shell is invoked by
.Xr exec 2 ,
and the first character of argument zero
.Pq Sy $0
is
.Sy - ,
then the shell is assumed to be a login shell and commands are read from
.Pa /etc/profile
and then from either
.Pa .profile
in the current directory or
.Pa $HOME/.profile ,
if either file exists.
Next, for interactive shells, commands are read first from
.Pa /etc/ksh.kshrc ,
and then from the file named by performing parameter expansion, command
substitution, and arithmetic substitution on the value of the environment
variable
.Ev ENV ,
if the file exists.
If the
.Fl s
option is not present and
.Ar arg
is specified and a file by the name of
.Ar arg
exists, then it reads and executes this script.
Otherwise, if the first
.Ar arg
does not contain a
.Sy / ,
a path search is performed on the first
.Ar arg
to determine the name of the script to execute.
The script
.Ar arg
must have execute permission and any
.Sy setuid
and
.Sy setgid
settings are ignored.
If the script is not found on the path,
.Ar arg
is processed as if it named a built-in command or function.
.Pp
Commands are then read as described, and the following options are interpreted
by the shell when it is invoked:
.Bl -tag -width Ds
.It Fl c
If the
.Fl c
option is present, then commands are read from the first
.Ar arg .
Any remaining arguments become positional parameters starting at
.Sy 0 .
.It Fl D
A list of all double quoted strings that are preceded by a
.Sy $
is printed on standard output and the shell exits.
This set of strings is subject to language translation when the locale is not C
or POSIX.
No commands are executed.
.It Fl E
Reads the file named by the
.Ev ENV
variable or by
.Pa $HOME/.kshrc
if not defined after the profiles.
.It Fl i
If the
.Fl i
option is present or if the shell input and output are attached to a terminal
.Pq as told by Xr tcgetattr 3C ) ,
this shell is interactive.
In this case
.Sy TERM
is ignored
.Po so that
.Ic kill Ar 0
does not kill an
interactive shell
.Pc
and
.Sy INTR
is caught and ignored
.Pq so that wait is interruptible .
In all cases,
.Sy QUIT
is ignored by the shell.
.It Fl R Ar filename
The
.Fl R Ar filename
option is used to generate a cross reference database that can be used by a
separate utility to find definitions and references for variables and commands.
.It Fl r
If the
.Fl r
option is present, the shell is a restricted shell.
.It Fl s
If the
.Fl s
option is present or if no arguments remain, then commands are read from the
standard input.
Shell output, except for the output of the
.Sx Special Commands
listed, is written to file descriptor 2.
.El
.Pp
The remaining options and arguments are described under the
.Ic set
command.
An optional
.Fl
as the first argument is ignored.
.Ss rksh93 Only
.Sy rksh93
is used to set up login names and execution environments whose capabilities are
more controlled than those of the standard shell.
.Pp
The actions of
.Nm rksh93
are identical to those of
.Nm ksh93 ,
except that the following are disallowed:
.Bl -bullet -width Ds
.It
Unsetting the restricted option
.It
Changing directory.
See
.Xr cd 1 .
.It
Setting or unsetting the value or attributes of
.Ev SHELL ,
.Ev ENV ,
.Ev FPATH ,
or
.Ev PATH
.It
Specifying path or command names containing
.Sy /
.It
Redirecting output
.Po
.Sy \&> ,
.Sy \&> ,
.Sy \&| ,
.Sy \&>\&; ,
.Sy \&<> ,
and
.Sy \&>>
.Pc .
.It
Adding or deleting built-in commands.
.It
Using
.Ic command Fl p
to invoke a command.
.El
.Pp
These restrictions are enforced after
.Pa .profile
and the
.Ev ENV
files are interpreted.
.Pp
When a command to be executed is found to be a shell procedure,
.Nm rksh93
invokes
.Nm ksh93
to execute it.
Thus, it is possible to provide to the end-user shell procedures that have
access to the full power of the standard shell, while imposing a limited menu
of commands.
This scheme assumes that the end-user does not have write and execute
permissions in the same directory.
The net effect of these rules is that the writer of the
.Pa .profile
has complete control over user actions, by performing guaranteed setup actions
and leaving the user in an appropriate directory (probably not the login
directory).
The system administrator often sets up a directory of commands, for example,
.Pa /usr/rbin ,
that can be safely invoked by
.Nm rksh93 .
.Sh USAGE
See
.Xr largefile 5
for the description of the behavior of
.Nm ksh93
and
.Nm rksh93
when encountering files greater than or equal to 2 Gbyte ( 2^31 bytes).
.Sh FILES
.Bl -tag -width Ds
.It Pa /etc/profile
The system initialization file, executed for login shells.
.It Pa /etc/ksh.kshrc
The system wide startup file, executed for interactive shells.
.It Pa $HOME/.profile
The personal initialization file, executed for login shells after
.Pa /etc/profile .
.It Pa $HOME/.kshrc
Default personal initialization file, executed after
.Pa /etc/ksh.kshrc ,
for interactive shells when
.Ev ENV
is not set.
.It Pa /etc/suid-profile
Alternative initialization file, executed instead of the personal
initialization file when the real and effective user or group id do not match.
.It Pa /dev/null
NULL device.
.El
.Sh EXIT STATUS
The following exit values are returned:
.Bl -tag -width Ds
.It Sy non-zero
Returns
.Sy non-zero
when errors, such as syntax errors, are detected by the shell.
.Pp
If the shell is being used non-interactively, then execution of the shell file
is abandoned unless the error occurs inside a sub-shell in which case the
sub-shell is abandoned.
.It Em exit-status-of-last-command-executed
Returns the exit status of the last command executed.
.Pp
Run time errors detected by the shell are reported by printing the command or
function name and the error condition.
If the line number that the error occurred on is greater than one, then the
line number is also printed in square brackets
.Pq Sy []
after the command or function name.
.Pp
See the
.Nm ksh93 Ic exit
command for additional details.
.El
.Sh INTERFACE STABILITY
The scripting interface is
.Sy Uncommitted .
The environment variables,
.Pa \&.paths
feature, and editing modes are
.Sy Volatile .
.Sh SEE ALSO
.Xr cat 1 ,
.Xr cd 1 ,
.Xr chmod 1 ,
.Xr cut 1 ,
.Xr date 1 ,
.Xr echo 1 ,
.Xr egrep 1 ,
.Xr env 1 ,
.Xr fgrep 1 ,
.Xr grep 1 ,
.Xr login 1 ,
.Xr newgrp 1 ,
.Xr paste 1 ,
.Xr perl 1 ,
.Xr printf 1 ,
.Xr stty 1 ,
.Xr test 1 ,
.Xr umask 1 ,
.Xr vi 1 ,
.Xr dup 2 ,
.Xr exec 2 ,
.Xr fork 2 ,
.Xr ioctl 2 ,
.Xr lseek 2 ,
.Xr pathconf 2 ,
.Xr pipe 2 ,
.Xr ulimit 2 ,
.Xr umask 2 ,
.Xr rand 3C ,
.Xr sysconf 3C ,
.Xr tcgetattr 3C ,
.Xr wait 3C ,
.Xr a.out 4 ,
.Xr profile 4 ,
.Xr attributes 5 ,
.Xr environ 5 ,
.Xr largefile 5 ,
.Xr standards 5
.Pp
.Rs
.%A Bolsky, Morris I.
.%A Korn, David G.
.%B The New KornShell Command and Programming Language
.%I Prentice Hall
.%D 1995 .
.Re
.Rs
.%B POSIX-Part 2: Shell and Utilities, IEEE Std 1003.2-1992, ISO/IEC 9945-2
.%I IEEE
.%D 1993 .
.Re
.Sh NOTES
.Nm ksh93
scripts should choose shell function names outside the namespace used by
reserved keywords of the ISO C99, C++ and JAVA languages to avoid collisions
with future enhancements to
.Nm ksh93 .
.Pp
If a command is executed, and then a command with the same name is installed in
a directory in the search path before the directory where the original command
was found, the shell continues to
.Ic exec
the original command.
Use the
.Fl t
option of the alias command to correct this situation.
.Pp
Some very old shell scripts contain a caret
.Pq Sy ^
as a synonym for the pipe character
.Pq Sy \&| .
.Pp
Using the
.Ic hist
built-in command within a compound command causes the whole command to
disappear from the history file.
.Pp
The built-in command
.Ic \&. Ar file
reads the whole file before any commands are executed.
.Ic alias
and
.Ic unalias
commands in the file do not apply to any commands defined in the file.
.Pp
Traps are not processed while a job is waiting for a foreground process.
Thus, a trap on
.Sy CHLD
is not executed until the foreground job terminates.
.Pp
It is a good idea to leave a space after the comma operator in arithmetic
expressions to prevent the comma from being interpreted as the decimal point
character in certain locales.
.Pp
There might be some restrictions on creating a
.Pa \&.paths
file which is portable across other operating systems.
.Pp
If the system supports the 64-bit instruction set,
.Pa /bin/ksh93
executes the 64-bit version of
.Nm ksh93 .
